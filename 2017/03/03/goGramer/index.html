<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>go lang 的学习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="win下安装go官网下载msi，安装后，指定路径，该指定会在Path中添加该/bin ,然后还会添加GOROOT路径所在，因为编译的时候回自动在%GOROOT%/src/name/所在路径寻找name.go,添加自主的GOPATH 可以定义一个自己的工作路径，后面编译会自动在%GOPATH%/src/name/下寻找name.go,并把文件编译在%GOPATH%/bin下
写在前面从对js的基本理">
<meta property="og:type" content="article">
<meta property="og:title" content="go lang 的学习">
<meta property="og:url" content="http://yoursite.com/2017/03/03/goGramer/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="win下安装go官网下载msi，安装后，指定路径，该指定会在Path中添加该/bin ,然后还会添加GOROOT路径所在，因为编译的时候回自动在%GOROOT%/src/name/所在路径寻找name.go,添加自主的GOPATH 可以定义一个自己的工作路径，后面编译会自动在%GOPATH%/src/name/下寻找name.go,并把文件编译在%GOPATH%/bin下
写在前面从对js的基本理">
<meta property="og:updated_time" content="2016-03-20T13:29:53.673Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go lang 的学习">
<meta name="twitter:description" content="win下安装go官网下载msi，安装后，指定路径，该指定会在Path中添加该/bin ,然后还会添加GOROOT路径所在，因为编译的时候回自动在%GOROOT%/src/name/所在路径寻找name.go,添加自主的GOPATH 可以定义一个自己的工作路径，后面编译会自动在%GOPATH%/src/name/下寻找name.go,并把文件编译在%GOPATH%/bin下
写在前面从对js的基本理">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-goGramer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/goGramer/" class="article-date">
  <time datetime="2017-03-03T11:20:16.279Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      go lang 的学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="win下安装go"><a href="#win下安装go" class="headerlink" title="win下安装go"></a>win下安装go</h3><p>官网下载msi，安装后，指定路径，该指定会在Path中添加该/bin ,然后还会添加GOROOT路径所在，因为编译的时候回自动在%GOROOT%/src/name/所在路径寻找name.go,添加自主的GOPATH 可以定义一个自己的工作路径，后面编译会自动在%GOPATH%/src/name/下寻找name.go,并把文件编译在%GOPATH%/bin下</p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）"><a href="#从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）" class="headerlink" title="从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）"></a>从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）</h4><p>js中，一切都是对象，那么在go中，也是差不多的（除了一些原始类型，如int等），那么包就可以看做是一个大对象，对包的import，就是对对象的import<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot; //包名即路径 </div><div class="line">	&quot;math/rand&quot; // 包名应该与路径的最后一个rand一致</div><div class="line">)</div><div class="line">// import 实际上得到了包的引用，暴露了一个可以引用某个包的变量，和js类似，只是js需要手动</div></pre></td></tr></table></figure></p>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func add(x, y int) int &#123;  //声明在后，函数的返回类型也要声明</div><div class="line">	return x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义多个变量</div><div class="line">var c, python, java bool // var开始，类型声明在后</div><div class="line"></div><div class="line">// 声明变量可以在包的头部或者函数体内头部</div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">var c, python, java bool</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i int</div><div class="line">	fmt.Println(i, c, python, java)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>变量都是要用var定义的，如果变量定义时没有初始化，需要在后声明类型，如果已经初始化，则不需要，它的类型会跟初始化值一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">var i, j  = 1, 2</div><div class="line">// 变量不允许多次定义，如var i = 8//会报错 </div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var c, python, java = true, false, &quot;no!&quot;</div><div class="line">	fmt.Println(i, j, c, python, java)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在每个包中，段变量声明只可以在函数体内，函数体外变量声明只能用var<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &quot;fmt&quot;</div><div class="line">p := 4 //报错，应改用var p = 4  </div><div class="line">func main() &#123;</div><div class="line">	var i, j  = 1, 2</div><div class="line">	k := 3 //短变量声明必须是要赋值了,也就是初始化</div><div class="line">	c, python, java := true, false, &quot;no!&quot;</div><div class="line"></div><div class="line">	fmt.Println(i, j, k, c, python, java)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="多结果返回值"><a href="#多结果返回值" class="headerlink" title="多结果返回值"></a>多结果返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">//如果返回值是多个，需要从左往右指定它的类型</div><div class="line">func swap(x, y string) (string, string) &#123;</div><div class="line">	return y, x</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">	a, b := swap(&quot;hello&quot;, &quot;world&quot;)  //变量声明也可以不用指定类型，但要在等号加入 := ,这样得到的类型会像js一样由内部智能分配</div><div class="line">	// 上面还用到了连续赋值 a, b := c, d</div><div class="line">	fmt.Println(a, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="裸return"><a href="#裸return" class="headerlink" title="裸return"></a>裸return</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func split(sum int) (x, y int) &#123;</div><div class="line">	x = sum * 4 / 9</div><div class="line">	y = sum - x</div><div class="line">	return // 裸return 会返回在函数头部声明的x, y (int) 类型这两个变量</div><div class="line">	//但是裸return会在长函数中伤害可读性</div><div class="line">	//但是裸return会在长函数中伤害可读性</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###E go的类型<br>go  的类型有int ,int8, string等，以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">bool</div><div class="line"></div><div class="line">string</div><div class="line"></div><div class="line">int  int8  int16  int32  int64</div><div class="line">uint uint8 uint16 uint32 uint64 uintptr //每一个类型都要注意溢出问题</div><div class="line"></div><div class="line">byte // alias for uint8</div><div class="line"></div><div class="line">rune // alias for int32</div><div class="line">     // represents a Unicode code point</div><div class="line"></div><div class="line">float32 float64</div><div class="line"></div><div class="line">complex64 complex128</div><div class="line">//</div><div class="line"></div><div class="line">// int ,unitptr, 类型一般是32位在32的系统，64位在64位系统</div><div class="line"></div><div class="line">var i int //如果没有初始化，会被赋值默认为0</div><div class="line"> var f float64 //总之数字型的复制为0，strign赋值为&quot;&quot;,string,需要用双引号</div><div class="line"> var b bool // false default</div><div class="line"></div><div class="line">// 类型转换</div><div class="line">``</div><div class="line">var i int = 42</div><div class="line">var f float64 = float64(i) //强制转换左边必须是新的变量，如var f是新的变量</div><div class="line">f = float32(i) //会报错</div><div class="line">//另外，如果变量声明了，没有被使用，引用，会出现报错，包也一样</div><div class="line"></div><div class="line">i := 42           // int</div><div class="line">f := 3.142        // float64</div><div class="line">g := 0.867 + 0.5i // complex128</div></pre></td></tr></table></figure></p>
<h4 id="go-的constans类型"><a href="#go-的constans类型" class="headerlink" title="go 的constans类型"></a>go 的constans类型</h4><p>constans 类型，不可以用 := 语法，值和类型不可以被改变<br>//注意，go中一旦定义了变量为int类型，就不可以直接把int变成string类型</p>
<p>constans类型用于表示数字类型时，可以动态一次性定义为高精度的数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">const (</div><div class="line">	Big   = 1 &lt;&lt; 100 //如果是int类型，最多只能是64位，但声明为const类型后，Big可以达到更高</div><div class="line">	Small = Big &gt;&gt; 99 //新的const 变量，Big 右移99位</div><div class="line">)</div><div class="line"></div><div class="line">func needInt(x int) int &#123; return x*10 + 1 &#125;</div><div class="line">func needFloat(x float64) float64 &#123;</div><div class="line">	return x * 0.1</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(needInt(Small))</div><div class="line">	fmt.Println(needFloat(Small))</div><div class="line">	fmt.Println(needFloat(Big))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><h4 id="for-go中只有一个循环语句，就是for"><a href="#for-go中只有一个循环语句，就是for" class="headerlink" title="for : go中只有一个循环语句，就是for"></a>for : go中只有一个循环语句，就是for</h4><p>for 语句没有了() ,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		sum += i</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="用for模仿while-continue"><a href="#用for模仿while-continue" class="headerlink" title="用for模仿while (continue)"></a>用for模仿while (continue)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	var i int</div><div class="line">	for ; sum &lt; 1000; &#123;</div><div class="line">		sum += sum</div><div class="line">		i += 1</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum, i) //1024 10 ,说明运行了10次，最后才大于1000</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 更简洁的写法</div><div class="line"></div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	for sum &lt; 1000 &#123;</div><div class="line">		sum += sum</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//死循环</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	for i := 0; i &lt; 10;  &#123; //这里没有退出条件，所以会死循环</div><div class="line">		sum += i</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 更简洁的死循环</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	for &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">if x &lt; 0 &#123;</div><div class="line">	return sqrt(-x) + &quot;i&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func pow(x, n, lim float64) float64 &#123;</div><div class="line">//if 可以先运行一段小代码，但是只拥有局部作用域</div><div class="line">	if v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">		return v</div><div class="line">	&#125;</div><div class="line">	//return v //会报错，提示没有这个变量</div><div class="line">	return lim</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(</div><div class="line">		pow(3, 2, 10),</div><div class="line">		pow(3, 3, 20),</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>if else ,在if中定义的变量，在else代码块中仍然有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func pow(x, n, lim float64) float64 &#123;</div><div class="line">	if v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">		return v</div><div class="line">	&#125; else &#123;</div><div class="line">		fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim)</div><div class="line">	&#125;</div><div class="line">	// can&apos;t use v here, though</div><div class="line">	return </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Print(&quot;Go runs on &quot;)</div><div class="line">	switch os := runtime.GOOS; os &#123; //先运行一小段代码，然后该变量在块中有效&#123;&#125;</div><div class="line">	case &quot;darwin&quot;:</div><div class="line">		fmt.Println(&quot;OS X.&quot;)</div><div class="line">	case &quot;linux&quot;:</div><div class="line">		fmt.Println(&quot;Linux.&quot;)</div><div class="line">	default:</div><div class="line">		// freebsd, openbsd,</div><div class="line">		// plan9, windows...</div><div class="line">		fmt.Printf(&quot;%s.&quot;, os)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//switch 里面的case可以运行小段代码后比较</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Print(&quot;Go runs on &quot;)</div><div class="line">	switch os := runtime.GOOS; os &#123;</div><div class="line">	case &quot;darwin&quot;:</div><div class="line">		fmt.Println(&quot;OS X.&quot;)</div><div class="line">	case &quot;linux&quot;:</div><div class="line">		fmt.Println(&quot;Linux.&quot;)</div><div class="line">	default:</div><div class="line">		// freebsd, openbsd,</div><div class="line">		// plan9, windows...</div><div class="line">		fmt.Printf(&quot;%s.&quot;, os)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>switch 代替长的if else链, 因为空的switch等于switch true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	t := time.Now()</div><div class="line">	switch &#123; //类似switch true ,当下面任何一个成立都会退出</div><div class="line">	case t.Hour() &lt; 12:</div><div class="line">		fmt.Println(&quot;Good morning!&quot;)</div><div class="line">	case t.Hour() &lt; 17:</div><div class="line">		fmt.Println(&quot;Good afternoon.&quot;)</div><div class="line">	default:</div><div class="line">		fmt.Println(&quot;Good evening.&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="defer-go中实现事情延时非常简洁-类似js的generate"><a href="#defer-go中实现事情延时非常简洁-类似js的generate" class="headerlink" title="defer go中实现事情延时非常简洁(类似js的generate)"></a>defer go中实现事情延时非常简洁(类似js的generate)</h4><p>虽然有了延时，只是延时到了所有任务执行完毕的下一个循环，但是没有js的手动启动它什么时候执行,由程序循环自动控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	defer fmt.Println(&quot;world&quot;)</div><div class="line"></div><div class="line">	fmt.Println(&quot;hello&quot;)</div><div class="line">	</div><div class="line">	defer fmt.Println(&quot;worl&quot;)</div><div class="line">	fmt.Println(&quot;helo&quot;)</div><div class="line"></div><div class="line">	//输出</div><div class="line">hello</div><div class="line">helo</div><div class="line">worl</div><div class="line">world</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>go 的defer 机制<br>遇到了defer关键字的，就先把该事件（语句）存放入一个栈，这个栈是先进后出原则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(&quot;counting&quot;)</div><div class="line"></div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		defer fmt.Println(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(&quot;done&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">9</div><div class="line">8</div><div class="line">7</div><div class="line">6</div><div class="line">5</div><div class="line">4</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h4 id="poiters-理解指针"><a href="#poiters-理解指针" class="headerlink" title="poiters, 理解指针"></a>poiters, 理解指针</h4><p>指针a是一个指向变量b的地址的变量，通过&amp;b 可以得到b的地址，通过*a 可以利用指针a来操作变量b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var p *int // 声明一个指向int类型的 指针</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func ch(t int) int &#123;</div><div class="line">	t = 33</div><div class="line">	return t</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	i, j := 42, 2701</div><div class="line"></div><div class="line">	p := &amp;i         // point to i //通过取i的地址，直接赋值给变量p</div><div class="line">	fmt.Println(*p) // read i through the pointer //通过指针操作符，*p,操作p所存地址的这个变量</div><div class="line">	*p = 88    // set i through the pointer</div><div class="line">	ch(*p)  //*p指针传值为对这个指针的复制 ,所以操作不会改变指针指向变量的值</div><div class="line">	t := *p //t是*p的一个复制</div><div class="line">	fmt.Println(i, t)  // see the new value of i</div><div class="line"></div><div class="line">	p = &amp;j         // point to j</div><div class="line">	*p = *p / 37   // divide j through the pointer</div><div class="line">	fmt.Println(j) // see the new value of j</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>彻底理解指针，变量就是一个地址加一个值，不管是什么东西，在内存中，都是一个地址，一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = 0 //变量a的值是0</div><div class="line">a += 5 //为什么直接调用a能改变a的值？因为默认了a就是拿到了a的值得存放地址，有了这个地址就可以操作a的值改变</div></pre></td></tr></table></figure></p>
<p>指针是一种间接操作，也就是先知道了某个变量的存放地址，那么知道了地址就要利用指针工具*来操纵它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">p := 8</div><div class="line">t := &amp;p //把p变量的存放地址赋值给t，也就是t的值是一个地址，（出于安全不可以改变t的值了，因为它的值是地址，但是t本身就是一个变量，也有它自己的地址）</div><div class="line">*t = 9 //t只能被指针操作符来操作了，也就是t的作用就是用来远程操作p，</div><div class="line">g := t //将g的值设置为t的值，也就是p的地址</div><div class="line">*g = 10 //同样可以远程操作到p</div><div class="line">g = 88 //会报错，因为g存放的是地址，不能改变了，只能传值,</div><div class="line">k := &amp;g // k变量保存为g的地址，但是g的值是p的地址，同理k的作用是远程操作g，而g的作用是远程操作p</div><div class="line">所以，只能用</div><div class="line">**k 来远程操作p，这里要看是什么用，记住地址为了安全，不能修改，只能赋值和远程操作</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 有关指针的完整例子，永远记得指针只是一个变量，只是有特殊标志，让人知道，只是在操作指针本身的值（地址）， 还是利用它操作它指向的地址的值</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 指针传值,因此可以实现改变内容，js中为引用传值，与这里实际上是一个道理，go/c中引用的概念相当于一个别名，并不是地址传值</div><div class="line">func cha(p *int) int &#123;</div><div class="line">	*p = 43432</div><div class="line">	return *p</div><div class="line">	&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	i, j := 42, 2701</div><div class="line"></div><div class="line">	p := &amp;i         // point to i</div><div class="line">	fmt.Println(*p) // read i through the pointer</div><div class="line">	*p = 21         // set i through the pointer</div><div class="line">	fmt.Println(i)  // see the new value of i</div><div class="line"></div><div class="line">	p = &amp;j         // point to j</div><div class="line">	*p = *p / 37   // divide j through the pointer</div><div class="line">	fmt.Println(j) // see the new value of j</div><div class="line">	</div><div class="line">	fmt.Println(cha(p), *p, j)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="go中复杂类型，如slice-array-map-等"><a href="#go中复杂类型，如slice-array-map-等" class="headerlink" title="go中复杂类型，如slice, array, map  等"></a>go中复杂类型，如slice, array, map  等</h5><p>结构体struct 用来更好的规划数据结构，但这非常节省内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	X int</div><div class="line">	Y int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(Vertex&#123;1, 2&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 指向struct的指针，默认不用*前置即可操作</div><div class="line">type Vertex struct &#123;</div><div class="line">	X int</div><div class="line">	Y int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	v := Vertex&#123;1, 2&#125; // 这个是type&#123;value&#125; 形式的，不同于前面value type ,而且是连着的</div><div class="line">	p := &amp;v</div><div class="line">	t := Vertex&#123;4, 6&#125; </div><div class="line">	p = &amp;t //指向struct的指针可以重新指向该类型的另一个地址</div><div class="line">	p.X = 1e9 //直接操作的就是指针</div><div class="line">	fmt.Println(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="array-数组是要有固定长度的"><a href="#array-数组是要有固定长度的" class="headerlink" title="array ,数组是要有固定长度的"></a>array ,数组是要有固定长度的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a [10]int</div><div class="line"></div><div class="line">var a [2]string</div><div class="line">a[0] = &quot;Hello&quot;</div><div class="line">a[1] = &quot;World&quot;</div><div class="line">fmt.Println(a[0], a[1])</div><div class="line"></div><div class="line">// 数组直接返回的是指针，而a[0] 是下一个指针,(记得指针是一种远程操纵，即代表是要操纵当然值(是一个地址)的值)</div></pre></td></tr></table></figure>
<h5 id="Slice是一种可变的“集合”-类似c中的动态数组-但比它要方便-应该是利用链表思维来实现的。-slice拥有长-length-度和容量-capacity-只有拥有长度才可以使用a-2-形式读取值，只有拥有容量，才可以切割a-b-cap-2-slice有特定的api来动态添加，操作-创建slice可以直接声明，声明加初始化，或者用make方法；"><a href="#Slice是一种可变的“集合”-类似c中的动态数组-但比它要方便-应该是利用链表思维来实现的。-slice拥有长-length-度和容量-capacity-只有拥有长度才可以使用a-2-形式读取值，只有拥有容量，才可以切割a-b-cap-2-slice有特定的api来动态添加，操作-创建slice可以直接声明，声明加初始化，或者用make方法；" class="headerlink" title="Slice是一种可变的“集合”, 类似c中的动态数组,但比它要方便,应该是利用链表思维来实现的。,slice拥有长(length)度和容量(capacity), 只有拥有长度才可以使用a[2]形式读取值，只有拥有容量，才可以切割a := b[:cap[2]], slice有特定的api来动态添加，操作; 创建slice可以直接声明，声明加初始化，或者用make方法；"></a>Slice是一种可变的“集合”, 类似c中的动态数组,但比它要方便,应该是利用链表思维来实现的。,slice拥有长(length)度和容量(capacity), 只有拥有长度才可以使用a[2]形式读取值，只有拥有容量，才可以切割a := b[:cap[2]], slice有特定的api来动态添加，操作; 创建slice可以直接声明，声明加初始化，或者用make方法；</h5><p>b := make([]int, 0, 5) // len(b)=0, cap(b)=5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//声明一个空slice : x []int //这个 slice长度和容量都是0</div><div class="line">//  声明一个非空slice必须先赋值</div><div class="line">s := []int&#123;2, 3, 5, 7, 11, 13&#125; // int类型的slice,与数组区别是，[len]不用表明，后面是初始值</div><div class="line"></div><div class="line">fmt.Println(&quot;s ==&quot;, s)</div><div class="line">fmt.Println(&quot;s[1:4] ==&quot;, s[1:4])</div><div class="line"></div><div class="line">// missing low index implies 0</div><div class="line">fmt.Println(&quot;s[:3] ==&quot;, s[:3])</div><div class="line"></div><div class="line">// missing high index implies len(s)</div><div class="line">fmt.Println(&quot;s[4:] ==&quot;, s[4:])</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// slice动态添加元素</div><div class="line">func main() &#123;</div><div class="line">	var s []int</div><div class="line">	printSlice(s)</div><div class="line"></div><div class="line">	// append works on nil slices.</div><div class="line">	s = append(s, 0)</div><div class="line">	printSlice(s)</div><div class="line"></div><div class="line">	// The slice grows as needed.</div><div class="line">	s = append(s, 1) // func append(s []T, vs ...T) []T</div><div class="line">	printSlice(s)</div><div class="line"></div><div class="line">	// We can add more than one element at a time.</div><div class="line">	s = append(s, 2, 3, 4)</div><div class="line">	printSlice(s)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func printSlice(s []int) &#123;</div><div class="line">	fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">for range 历遍一个 slice</div><div class="line"></div><div class="line">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	for i, v := range pow &#123;</div><div class="line">		fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 历遍slice需要得到它的index和value，当然可以更高效，只使用它的值</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	pow := make([]int, 10)</div><div class="line">	for i := range pow &#123;</div><div class="line">		pow[i] = 1 &lt;&lt; uint(i) // == 2**i</div><div class="line">	&#125;</div><div class="line">	for _, value := range pow &#123; //用_, 代表忽略index</div><div class="line">		fmt.Printf(&quot;%d\n&quot;, value)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 如果只要索引index</div><div class="line">	for i := range pow &#123;</div><div class="line">		fmt.Printf(i)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="复杂类型除了slice还有map-这两个是最基本的-slice可以动态添加，map也可以-创建map必须使用make方法"><a href="#复杂类型除了slice还有map-这两个是最基本的-slice可以动态添加，map也可以-创建map必须使用make方法" class="headerlink" title="复杂类型除了slice还有map  (这两个是最基本的),slice可以动态添加，map也可以,创建map必须使用make方法"></a>复杂类型除了slice还有map  (这两个是最基本的),slice可以动态添加，map也可以,创建map必须使用make方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var m map[string]Vertex //声明一个map ,其中要表明key, value的类型</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	m = make(map[string]Vertex) //实际上还是需要用make方法</div><div class="line">	m[&quot;Bell Labs&quot;] = Vertex&#123;</div><div class="line">		40.68433, -74.39967,</div><div class="line">	&#125;</div><div class="line">	fmt.Println(m[&quot;Bell Labs&quot;])</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	Lat, Long float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 以下却不用写make方法</div><div class="line">var m = map[string]Vertex&#123;</div><div class="line">	&quot;Bell Labs&quot;: Vertex&#123;</div><div class="line">		40.68433, -74.39967,</div><div class="line">	&#125;,</div><div class="line">	&quot;Google&quot;: Vertex&#123;</div><div class="line">		37.42202, -122.08408,</div><div class="line">	&#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="函数与闭包-函数可以作为值传过来，也可以使用闭包"><a href="#函数与闭包-函数可以作为值传过来，也可以使用闭包" class="headerlink" title="函数与闭包, 函数可以作为值传过来，也可以使用闭包"></a>函数与闭包, 函数可以作为值传过来，也可以使用闭包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func compute(fn func(float64, float64) float64) float64 &#123;</div><div class="line">	return fn(3, 4)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	hypot := func(x, y float64) float64 &#123;</div><div class="line">		return math.Sqrt(x*x + y*y)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(hypot(5, 12))</div><div class="line"></div><div class="line">	fmt.Println(compute(hypot))</div><div class="line">	fmt.Println(compute(math.Pow))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 闭包</div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func adder() func(int) int &#123;</div><div class="line">	sum := 0</div><div class="line">	return func(x int) int &#123;</div><div class="line">		sum += x</div><div class="line">		return sum</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	pos, neg := adder(), adder()</div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		fmt.Println(</div><div class="line">			pos(i),</div><div class="line">			neg(-2*i),</div><div class="line">		)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>操纵map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 有map m</div><div class="line">新增或者修改</div><div class="line">m[key] = value</div><div class="line"></div><div class="line">获取</div><div class="line">m[key]</div><div class="line"></div><div class="line">删除</div><div class="line">delete(m, key)</div><div class="line"></div><div class="line">测试map中是否有该key </div><div class="line"></div><div class="line">elem, ok := m[key]</div><div class="line">// 如果有ok为true,且elem等于该key的值</div></pre></td></tr></table></figure>
<h4 id="go中的面向对象"><a href="#go中的面向对象" class="headerlink" title="go中的面向对象"></a>go中的面向对象</h4><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>go 的面向对象是基于结构体的（struct），结构体本来只有变量，但是应该把函数也看做变量，即把新定义的方法（函数）发送到struct中，然后它接收就可以实现了方法和变量同在，也就是类了。</p>
<p>类的成员有属性与方法，属性是每个类都独立的，而方法是每个类共有的，go中有种机制，可以用strut 定义类中所有属性，然后利用类似接收者机制，把一个方法归结到stuct中使用，合成了一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	X, Y float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func Abs(v Vertex) float64 &#123;  //普通函数,传入一个v, (复制传值)</div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v Vertex) Abs() float64 &#123; // 类的方法(区别于普通函数，因为它显式表明了接收者是Vertex类型的v，)</div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	v := Vertex&#123;3, 4&#125;</div><div class="line">	fmt.Println(Abs(v))</div><div class="line">	v := Vertex&#123;3, 4&#125;</div><div class="line">	fmt.Println(v.Abs())</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 不管是函数形式还是接收者形式实现“类”，都要利用指针，以便可以直接修改值，和实现更高的效率，（不用复制一份）</div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	X, Y float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v *Vertex) Scale(f float64) &#123; //类的方法</div><div class="line">	v.X = v.X * f //sturct中使用指针不用前置 *</div><div class="line">	v.Y = v.Y * f</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v *Vertex) Abs() float64 &#123; </div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	v := &amp;Vertex&#123;3, 4&#125;</div><div class="line">	fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</div><div class="line">	v.Scale(5)</div><div class="line">	fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口其实就是换装，即把不同名称的类，（但这些类有共同的方法）附加到接口中，或者反过来说，就是定义接口，然后用不同的类实现它.</p>
<p>go 中的接口实现与go中实现类的方法类似，定义接口时，只需定义接口存在的方法，然后直接让该接口等于任何一个实现了这个方法的类即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type Abser interface &#123; // 声明一个接口</div><div class="line">	Abs() float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var a Abser //声明一个接口值</div><div class="line">	f := MyFloat(-math.Sqrt2)</div><div class="line">	v := Vertex&#123;3, 4&#125;</div><div class="line"></div><div class="line">	a = f  // a MyFloat implements Abser //使用接口实现即使直接赋值</div><div class="line">	a = &amp;v // a *Vertex implements Abser //如果实现方法利用指针就要传地址</div><div class="line"></div><div class="line">	// In the following line, v is a Vertex (not *Vertex)</div><div class="line">	// and does NOT implement Abser.</div><div class="line">	//a = v</div><div class="line"></div><div class="line">	fmt.Println(a.Abs())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接口实现极为简单（思维当作js中的标识型实现接口）, 只需要在类中有这个方法(实现这个方法)即可</div><div class="line">type MyFloat float64</div><div class="line"></div><div class="line">func (f MyFloat) Abs() float64 &#123;</div><div class="line">	if f &lt; 0 &#123;</div><div class="line">		return float64(-f)</div><div class="line">	&#125;</div><div class="line">	return float64(f)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这里也是同理,书写接口实现就是写一个类</div><div class="line">type Vertex struct &#123;</div><div class="line">	X, Y float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v *Vertex) Abs() float64 &#123;</div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">空接口</div><div class="line"></div><div class="line"></div><div class="line">type I interface &#123;</div><div class="line">	M()</div><div class="line">&#125;</div><div class="line"></div><div class="line">type T struct &#123;</div><div class="line">	S string</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *T) M() &#123;</div><div class="line">	if t == nil &#123;</div><div class="line">		fmt.Println(&quot;&lt;nil&gt;&quot;)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	fmt.Println(t.S)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i I</div><div class="line"></div><div class="line">	var t *T</div><div class="line">	i = t</div><div class="line">	describe(i)</div><div class="line">	i.M()</div><div class="line"></div><div class="line">	i = &amp;T&#123;&quot;hello&quot;&#125;</div><div class="line">	describe(i)</div><div class="line">	i.M()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func describe(i I) &#123;</div><div class="line">	fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 空接口可以包含任何值</div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i interface&#123;&#125; // 这里是一个空接口</div><div class="line">	describe(i)</div><div class="line"></div><div class="line">	i = 42</div><div class="line">	describe(i)</div><div class="line"></div><div class="line">	i = &quot;hello&quot;</div><div class="line">	describe(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func describe(i interface&#123;&#125;) &#123;</div><div class="line">	fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口类型判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i interface&#123;&#125; = &quot;hello&quot;</div><div class="line"></div><div class="line">	s := i.(string) //判断接口是不是string类型</div><div class="line">	fmt.Println(s)</div><div class="line"></div><div class="line">	s, ok := i.(string)</div><div class="line">	fmt.Println(s, ok)</div><div class="line"></div><div class="line">	f, ok := i.(float64)</div><div class="line">	fmt.Println(f, ok)</div><div class="line"></div><div class="line">	f = i.(float64) // panic</div><div class="line">	fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>string类型有许多内置方法，如打印时，默认是调用String()方法来输出打印行为，如果实现该接口，那么可以自定义打印输出行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type Person struct &#123;</div><div class="line">	Name string</div><div class="line">	Age  int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (p Person) String() string &#123;</div><div class="line">	return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;</div><div class="line">	z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;</div><div class="line">	fmt.Println(a, z)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="错误处理，类似stinger-每个操作go中都有错误处理接口，只要实现-了自己的错误处理方法，就可以使用自己的方法来处理错误"><a href="#错误处理，类似stinger-每个操作go中都有错误处理接口，只要实现-了自己的错误处理方法，就可以使用自己的方法来处理错误" class="headerlink" title="错误处理，类似stinger, 每个操作go中都有错误处理接口，只要实现 了自己的错误处理方法，就可以使用自己的方法来处理错误"></a>错误处理，类似stinger, 每个操作go中都有错误处理接口，只要实现 了自己的错误处理方法，就可以使用自己的方法来处理错误</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type MyError struct &#123;</div><div class="line">	When time.Time</div><div class="line">	What string</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (e *MyError) Error() string &#123;</div><div class="line">	return fmt.Sprintf(&quot;at %v, %s&quot;,</div><div class="line">		e.When, e.What)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func run() error &#123;</div><div class="line">	return &amp;MyError&#123;</div><div class="line">		time.Now(),</div><div class="line">		&quot;it didn&apos;t work&quot;,</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	if err := run(); err != nil &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="go-goroutine"><a href="#go-goroutine" class="headerlink" title="go goroutine"></a>go goroutine</h5><p>go中的协程，是一种超级轻量化的协程，宏观工作方式类似进程，即运行协程后，协程会在跟当前协程平行的协程中独立运行，(但却可以共享内存), 如果新的独立协程有异步行动，当前协程需要用到，那么当前协程会像同步进程一样等待。但是如果同时创建多条新的协程，这多条协程之间是独立，并且互相平行工作</p>
<p>协程之间通过chanel + 管道来通信，想象每个协程是独立的一个人，然后回监听一条或者多条管道，如果管道有内容过来，就开始特定的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func sum(a []int, c chan int) &#123;</div><div class="line">	sum := 0</div><div class="line">	for _, v := range a &#123;</div><div class="line">		sum += v</div><div class="line">	&#125;</div><div class="line">	c &lt;- sum // 将和送入 管道c</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	a := []int&#123;7, 2, 8, -9, 4, 0&#125;</div><div class="line"></div><div class="line">	c := make(chan int) // 声明一个管道</div><div class="line">	go sum(a[:len(a)/2], c) //协程独立运行,并往下</div><div class="line">	go sum(a[len(a)/2:], c) //协程独立运行,并往下</div><div class="line">	go fmt.Println(&quot;t&quot;) //协程独立运行,因为这个比较快，会先得到返回，</div><div class="line">	x, y := &lt;-c, &lt;-c // 从 c 中获取 //后面的必须等待前面所有协程运行完毕才执行,因为管道的另一端没有准备好，会阻塞</div><div class="line"></div><div class="line">	fmt.Println(x, y, x+y)</div><div class="line">	fmt.Println(434)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func fibonacci(n int, c chan int) &#123;</div><div class="line">	x, y := 0, 1</div><div class="line">	for i := 0; i &lt; n; i++ &#123;</div><div class="line">		c &lt;- x</div><div class="line">		x, y = y, x+y</div><div class="line">	&#125;</div><div class="line">	close(c) //先是不断向管道中送数据，最后发送一个结束信号</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	c := make(chan int, 10)</div><div class="line">	go fibonacci(cap(c), c) //抛出一条新的协程,独立工作，程序往下执行</div><div class="line">	for i := range c &#123;  //不断从管道中抽取内容, 直到结束</div><div class="line">		fmt.Println(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(&apos;test order&apos;) //最后运行，因为前面的没有完全运行完</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func fibonacci(c, quit chan int) &#123;</div><div class="line">	x, y := 0, 1</div><div class="line">	for &#123; //不断循环，但是当条件不满足时，会阻塞</div><div class="line">		select &#123;</div><div class="line">		case c &lt;- x:  //如果可以往管道中送入x值，就执行它</div><div class="line">			x, y = y, x+y</div><div class="line">		case &lt;-quit: //如果能从管道quit中取出值，就执行它</div><div class="line">			fmt.Println(&quot;quit&quot;)</div><div class="line">			return // 结束for循环</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	c := make(chan int)</div><div class="line">	quit := make(chan int)</div><div class="line">	go func() &#123; //抛出协程，独立工作，往下 执行</div><div class="line">		for i := 0; i &lt; 10; i++ &#123;</div><div class="line">			fmt.Println(&lt;-c) //这个协程不断读取c管道值十次,一般情况下发送和读取时配套的，所以fibonacci协程会在十次之后不向c管道发送内容了</div><div class="line">		&#125;</div><div class="line">		quit &lt;- 1</div><div class="line">	&#125;()</div><div class="line">	fibonacci(c, quit)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 锁，控制某一个值同一时刻只被一个协程访问</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;sync&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// SafeCounter 的并发使用是安全的。</div><div class="line">type SafeCounter struct &#123;</div><div class="line">	v   map[string]int</div><div class="line">	mux sync.Mutex</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Inc 增加给定 key 的计数器的值。,类的方法</div><div class="line">func (c *SafeCounter) Inc(key string) &#123;</div><div class="line">	//c.mux.Lock()</div><div class="line">	// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</div><div class="line">	c.v[key]++</div><div class="line">	//c.mux.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Value 返回给定 key 的计数器的当前值。</div><div class="line">func (c *SafeCounter) Value(key string) int &#123;</div><div class="line">	//c.mux.Lock()</div><div class="line">	// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</div><div class="line">	defer c.mux.Unlock() //用defer保证一定会被解锁</div><div class="line">	return c.v[key]</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	c := SafeCounter&#123;v: make(map[string]int)&#125;</div><div class="line">	for i := 0; i &lt; 1000; i++ &#123;</div><div class="line">		go c.Inc(&quot;somekey&quot;) //并发1000个协程</div><div class="line">		//fmt.Println(44)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	time.Sleep(time.Second)</div><div class="line">	fmt.Println(c.Value(&quot;somekey&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/goGramer/" data-id="cizut7q2w000it4ddlunj3nbn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/03/gulp/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/03/03/go/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">golang learning</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/03/yii/session/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/03/hexo/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/03/winTips/">一些小技巧</a>
          </li>
        
          <li>
            <a href="/2017/03/03/win7Clean/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/03/webpack/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>