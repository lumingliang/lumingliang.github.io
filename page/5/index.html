<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-gulp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/gulp/" class="article-date">
  <time datetime="2017-03-03T11:20:16.280Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="这里是前端工具gulp和webpack的基础用法学习"><a href="#这里是前端工具gulp和webpack的基础用法学习" class="headerlink" title="这里是前端工具gulp和webpack的基础用法学习"></a>这里是前端工具gulp和webpack的基础用法学习</h4><hr>
<h5 id="gulp-automate-and-enhance-my-wokflow"><a href="#gulp-automate-and-enhance-my-wokflow" class="headerlink" title="gulp ,automate and enhance my wokflow!"></a>gulp ,automate and enhance my wokflow!</h5><ul>
<li>安装：npm install gulp-cli -g //全局安装cli</li>
<li>npm install gulp –save-dev //install gulp in current project, and save detail in package.json</li>
<li>创建gulpfile.js , 里面配置了所有gulp的工作，当前gulp会调用gulp自身和它的一些有用插件来自动完成所有工作</li>
</ul>
<h5 id="all-api-for-gulp-gulp-src-gulp-dest-gulp-task-gulp-watch"><a href="#all-api-for-gulp-gulp-src-gulp-dest-gulp-task-gulp-watch" class="headerlink" title="all api for gulp , gulp.src,gulp.dest, gulp.task, gulp.watch"></a>all api for gulp , gulp.src,gulp.dest, gulp.task, gulp.watch</h5><p>下面一一讲解这些api的用法</p>
<p>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gulp.src(&apos;client/templates/*.jade&apos;) // 获取源文件(待处理文件)</div><div class="line">  .pipe(jade()) //通过pipe使文件作为输出，并输入给jade()处理后继续输出,这里实现了预编译jade语法的文件</div><div class="line">  .pipe(minify()) // 继续用minify处理,即压缩</div><div class="line">  .pipe(gulp.dest(&apos;build/minified_templates&apos;)); // gulp.dest输出到目的地</div></pre></td></tr></table></figure></p>
<p>上面代码jade,minify方法需要npm install plugin,然后参照plugin使用它，gulp只起到输入，输出，和整合调用其他插件的作用</p>
<p>gulp.src原型为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">gulp.src(globs[, options]) </div><div class="line">globs 一般是strings，或者strings 数组(即多个), 后面的options是附加设置</div><div class="line"></div><div class="line">// 如下目录</div><div class="line">client/</div><div class="line">  a.js</div><div class="line">  bob.js</div><div class="line">  bad.js</div><div class="line"></div><div class="line">gulp.src([&apos;client/*.js&apos;, &apos;!client/b*.js&apos;, &apos;client/bad.js&apos;]) // 只会匹配a.js, bad.js</div><div class="line"></div><div class="line">// options = &#123;</div><div class="line">	buffe: defualt(false) // 当为true时，读取文件将会以流steam形式，而不是全部读进缓冲区,这对读取大文件有用，但不是每个插件支持stream形式</div><div class="line">	read: true // 设置为flase会返回null,而且不会读取文件</div><div class="line">	base: &apos;string&apos; // 设置输出和输入 的路径问题，参考以下代码</div><div class="line">&#125;</div><div class="line"></div><div class="line">gulp.src(&apos;client/js/**/*.js&apos;) // </div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(&apos;build&apos;));  // Writes &apos;build/somedir/somefile.js&apos;</div><div class="line"></div><div class="line">gulp.src(&apos;client/js/**/*.js&apos;, &#123; base: &apos;client&apos; &#125;)</div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(&apos;build&apos;));  // Writes &apos;build/js/somedir/somefile.js&apos;</div></pre></td></tr></table></figure></p>
<p>gulp.dest(path, [, options]) , path是在gulpfile目录基础下的子目录，如果没有就创建它,options取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">options = &#123;</div><div class="line">	cwd: ?,</div><div class="line">	mode: 0777(默认),设定目录权限</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gulp.task(name, [, deps, fn]), name是task的名字，deps是一个其他任务名数组，因为各个task之间是并发运行的，要保证当前task 在其他task之后运行就要把它写入数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123;</div><div class="line">  // Do stuff</div><div class="line">&#125;); // 数组内的所有都会同时运行，mytask要在数组task后运行，需要数组内的任务正确使用promise等。</div><div class="line"></div><div class="line">以上所有的任务内容都是写在task回调中。</div></pre></td></tr></table></figure>
<p>异步task的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 使用回调</div><div class="line">// run a command in a shell</div><div class="line">var exec = require(&apos;child_process&apos;).exec;</div><div class="line">gulp.task(&apos;jekyll&apos;, function(cb) &#123;</div><div class="line">  // build Jekyll</div><div class="line">  exec(&apos;jekyll build&apos;, function(err) &#123;</div><div class="line">    if (err) return cb(err); // return error</div><div class="line">    cb(); // finished task</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 返回一个stream</div><div class="line">gulp.task(&apos;somename&apos;, function() &#123;</div><div class="line">  var stream = gulp.src(&apos;client/**/*.js&apos;)</div><div class="line">    .pipe(minify())</div><div class="line">    .pipe(gulp.dest(&apos;build&apos;));</div><div class="line">  return stream;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 返回一个promise</div><div class="line">var Q = require(&apos;q&apos;);</div><div class="line"></div><div class="line">gulp.task(&apos;somename&apos;, function() &#123;</div><div class="line">  var deferred = Q.defer();</div><div class="line"></div><div class="line">  // do async stuff</div><div class="line">  setTimeout(function() &#123;</div><div class="line">    deferred.resolve();</div><div class="line">  &#125;, 1);</div><div class="line"></div><div class="line">  return deferred.promise;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h5 id="任务互相依赖，如b依赖a的先完成，那么应该按照上面的异步写法写a-返回promise，等让gulp知道它什么时候完成，然后在b的options中声明依赖数组，gulp就自动知道了"><a href="#任务互相依赖，如b依赖a的先完成，那么应该按照上面的异步写法写a-返回promise，等让gulp知道它什么时候完成，然后在b的options中声明依赖数组，gulp就自动知道了" class="headerlink" title="任务互相依赖，如b依赖a的先完成，那么应该按照上面的异步写法写a,返回promise，等让gulp知道它什么时候完成，然后在b的options中声明依赖数组，gulp就自动知道了"></a>任务互相依赖，如b依赖a的先完成，那么应该按照上面的异步写法写a,返回promise，等让gulp知道它什么时候完成，然后在b的options中声明依赖数组，gulp就自动知道了</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;);</div><div class="line"></div><div class="line">// takes in a callback so the engine knows when it&apos;ll be done</div><div class="line">gulp.task(&apos;one&apos;, function(cb) &#123;</div><div class="line">    // do stuff -- async or otherwise</div><div class="line">    cb(err); // if err is not null and not undefined, the run will stop, and note that it failed</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// identifies a dependent task must be complete before this one begins</div><div class="line">gulp.task(&apos;two&apos;, [&apos;one&apos;], function() &#123;</div><div class="line">    // task &apos;one&apos; is done now</div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(&apos;default&apos;, [&apos;one&apos;, &apos;two&apos;]);</div></pre></td></tr></table></figure>
<h5 id="gulp-watch-glob-opts-tasks-or-gulp-watch-glob-opts-cb"><a href="#gulp-watch-glob-opts-tasks-or-gulp-watch-glob-opts-cb" class="headerlink" title="gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb])"></a>gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb])</h5><p>glob是要监测的文件(or file数组),opts是监测的行为，如’reload’, tasks当发生这些监测行为时要运行的任务，或者使用cb,当行为发生时要运行的cb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cb(event) //cb中附带有event参数，可以读取发生该事件的上下文，如path, type</div><div class="line"></div><div class="line">gulp.watch(&apos;js/**/*.js&apos;, function(event) &#123;</div><div class="line">  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);</div><div class="line">watcher.on(&apos;change&apos;, function(event) &#123;</div><div class="line">  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="gulp插件，所有的自动化行为大多依赖插件完成"><a href="#gulp插件，所有的自动化行为大多依赖插件完成" class="headerlink" title="gulp插件，所有的自动化行为大多依赖插件完成"></a>gulp插件，所有的自动化行为大多依赖插件完成</h5><p>以下说明主要有用插件<br>编译Sass (gulp-ruby-sass)<br>Autoprefixer (gulp-autoprefixer)<br>缩小化(minify)CSS (gulp-minify-css)<br>JSHint (gulp-jshint)<br>拼接 (gulp-concat)<br>丑化(Uglify) (gulp-uglify)<br>图片压缩 (gulp-imagemin)<br>即时重整(LiveReload) (gulp-livereload)<br>清理档案 (gulp-clean)<br>图片快取，只有更改过得图片会进行压缩 (gulp-cache)<br>更动通知 (gulp-notify)</p>
<p>// 安装插件命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-clean gulp-notify gulp-rename gulp-livereload gulp-cache --save-dev</div></pre></td></tr></table></figure></p>
<p>// 使用插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;),  </div><div class="line">    sass = require(&apos;gulp-ruby-sass&apos;),</div><div class="line">    autoprefixer = require(&apos;gulp-autoprefixer&apos;),</div><div class="line">    minifycss = require(&apos;gulp-minify-css&apos;),</div><div class="line">    jshint = require(&apos;gulp-jshint&apos;),</div><div class="line">    uglify = require(&apos;gulp-uglify&apos;),</div><div class="line">    imagemin = require(&apos;gulp-imagemin&apos;),</div><div class="line">    rename = require(&apos;gulp-rename&apos;),</div><div class="line">    clean = require(&apos;gulp-clean&apos;),</div><div class="line">    concat = require(&apos;gulp-concat&apos;),</div><div class="line">    notify = require(&apos;gulp-notify&apos;),</div><div class="line">    cache = require(&apos;gulp-cache&apos;),</div><div class="line">    livereload = require(&apos;gulp-livereload&apos;);</div></pre></td></tr></table></figure></p>
<p>简单任务: 编译sass, 自动加入浏览器前缀，重命名，最小化压缩， <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;styles&apos;, function() &#123;  </div><div class="line">  return gulp.src(&apos;src/styles/main.scss&apos;)</div><div class="line">    .pipe(sass(&#123; style: &apos;expanded&apos; &#125;))</div><div class="line">    .pipe(autoprefixer(&apos;last 2 version&apos;, &apos;safari 5&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;, &apos;opera 12.1&apos;, &apos;ios 6&apos;, &apos;android 4&apos;))</div><div class="line">    .pipe(gulp.dest(&apos;dist/assets/css&apos;))</div><div class="line">    .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</div><div class="line">    .pipe(minifycss())</div><div class="line">    .pipe(gulp.dest(&apos;dist/assets/css&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;Styles task complete&apos; &#125;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>jshint, 检查后压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;scripts&apos;, function() &#123;  </div><div class="line">return gulp.src(&apos;src/scripts/**/*.js&apos;)</div><div class="line"> .pipe(jshint(&apos;.jshintrc&apos;))</div><div class="line"> .pipe(jshint.reporter(&apos;default&apos;))</div><div class="line"> .pipe(concat(&apos;main.js&apos;))</div><div class="line"> .pipe(gulp.dest(&apos;dist/assets/js&apos;))</div><div class="line"> .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</div><div class="line"> .pipe(uglify())</div><div class="line"> .pipe(gulp.dest(&apos;dist/assets/js&apos;))</div><div class="line"> .pipe(notify(&#123; message: &apos;Scripts task complete&apos; &#125;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><a href="http://www.jianshu.com/p/3f2e13442555" target="_blank" rel="external">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/gulp/" data-id="cizut7q2y000jt4dd8oir43go" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-goGramer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/goGramer/" class="article-date">
  <time datetime="2017-03-03T11:20:16.279Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/03/goGramer/">go lang 的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="win下安装go"><a href="#win下安装go" class="headerlink" title="win下安装go"></a>win下安装go</h3><p>官网下载msi，安装后，指定路径，该指定会在Path中添加该/bin ,然后还会添加GOROOT路径所在，因为编译的时候回自动在%GOROOT%/src/name/所在路径寻找name.go,添加自主的GOPATH 可以定义一个自己的工作路径，后面编译会自动在%GOPATH%/src/name/下寻找name.go,并把文件编译在%GOPATH%/bin下</p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）"><a href="#从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）" class="headerlink" title="从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）"></a>从对js的基本理解到真正学习一门强大的语言，需要很多时间，而其中我这个战场也拉大了，（因为没有学习稳扎的js，但是因为好奇和时间和一些类似的因素，我决定先尝尝鲜，然后回头再来整合所有）</h4><p>js中，一切都是对象，那么在go中，也是差不多的（除了一些原始类型，如int等），那么包就可以看做是一个大对象，对包的import，就是对对象的import<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot; //包名即路径 </div><div class="line">	&quot;math/rand&quot; // 包名应该与路径的最后一个rand一致</div><div class="line">)</div><div class="line">// import 实际上得到了包的引用，暴露了一个可以引用某个包的变量，和js类似，只是js需要手动</div></pre></td></tr></table></figure></p>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func add(x, y int) int &#123;  //声明在后，函数的返回类型也要声明</div><div class="line">	return x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义多个变量</div><div class="line">var c, python, java bool // var开始，类型声明在后</div><div class="line"></div><div class="line">// 声明变量可以在包的头部或者函数体内头部</div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">var c, python, java bool</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i int</div><div class="line">	fmt.Println(i, c, python, java)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>变量都是要用var定义的，如果变量定义时没有初始化，需要在后声明类型，如果已经初始化，则不需要，它的类型会跟初始化值一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">var i, j  = 1, 2</div><div class="line">// 变量不允许多次定义，如var i = 8//会报错 </div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var c, python, java = true, false, &quot;no!&quot;</div><div class="line">	fmt.Println(i, j, c, python, java)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在每个包中，段变量声明只可以在函数体内，函数体外变量声明只能用var<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &quot;fmt&quot;</div><div class="line">p := 4 //报错，应改用var p = 4  </div><div class="line">func main() &#123;</div><div class="line">	var i, j  = 1, 2</div><div class="line">	k := 3 //短变量声明必须是要赋值了,也就是初始化</div><div class="line">	c, python, java := true, false, &quot;no!&quot;</div><div class="line"></div><div class="line">	fmt.Println(i, j, k, c, python, java)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="多结果返回值"><a href="#多结果返回值" class="headerlink" title="多结果返回值"></a>多结果返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">//如果返回值是多个，需要从左往右指定它的类型</div><div class="line">func swap(x, y string) (string, string) &#123;</div><div class="line">	return y, x</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">	a, b := swap(&quot;hello&quot;, &quot;world&quot;)  //变量声明也可以不用指定类型，但要在等号加入 := ,这样得到的类型会像js一样由内部智能分配</div><div class="line">	// 上面还用到了连续赋值 a, b := c, d</div><div class="line">	fmt.Println(a, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="裸return"><a href="#裸return" class="headerlink" title="裸return"></a>裸return</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func split(sum int) (x, y int) &#123;</div><div class="line">	x = sum * 4 / 9</div><div class="line">	y = sum - x</div><div class="line">	return // 裸return 会返回在函数头部声明的x, y (int) 类型这两个变量</div><div class="line">	//但是裸return会在长函数中伤害可读性</div><div class="line">	//但是裸return会在长函数中伤害可读性</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###E go的类型<br>go  的类型有int ,int8, string等，以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">bool</div><div class="line"></div><div class="line">string</div><div class="line"></div><div class="line">int  int8  int16  int32  int64</div><div class="line">uint uint8 uint16 uint32 uint64 uintptr //每一个类型都要注意溢出问题</div><div class="line"></div><div class="line">byte // alias for uint8</div><div class="line"></div><div class="line">rune // alias for int32</div><div class="line">     // represents a Unicode code point</div><div class="line"></div><div class="line">float32 float64</div><div class="line"></div><div class="line">complex64 complex128</div><div class="line">//</div><div class="line"></div><div class="line">// int ,unitptr, 类型一般是32位在32的系统，64位在64位系统</div><div class="line"></div><div class="line">var i int //如果没有初始化，会被赋值默认为0</div><div class="line"> var f float64 //总之数字型的复制为0，strign赋值为&quot;&quot;,string,需要用双引号</div><div class="line"> var b bool // false default</div><div class="line"></div><div class="line">// 类型转换</div><div class="line">``</div><div class="line">var i int = 42</div><div class="line">var f float64 = float64(i) //强制转换左边必须是新的变量，如var f是新的变量</div><div class="line">f = float32(i) //会报错</div><div class="line">//另外，如果变量声明了，没有被使用，引用，会出现报错，包也一样</div><div class="line"></div><div class="line">i := 42           // int</div><div class="line">f := 3.142        // float64</div><div class="line">g := 0.867 + 0.5i // complex128</div></pre></td></tr></table></figure></p>
<h4 id="go-的constans类型"><a href="#go-的constans类型" class="headerlink" title="go 的constans类型"></a>go 的constans类型</h4><p>constans 类型，不可以用 := 语法，值和类型不可以被改变<br>//注意，go中一旦定义了变量为int类型，就不可以直接把int变成string类型</p>
<p>constans类型用于表示数字类型时，可以动态一次性定义为高精度的数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">const (</div><div class="line">	Big   = 1 &lt;&lt; 100 //如果是int类型，最多只能是64位，但声明为const类型后，Big可以达到更高</div><div class="line">	Small = Big &gt;&gt; 99 //新的const 变量，Big 右移99位</div><div class="line">)</div><div class="line"></div><div class="line">func needInt(x int) int &#123; return x*10 + 1 &#125;</div><div class="line">func needFloat(x float64) float64 &#123;</div><div class="line">	return x * 0.1</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(needInt(Small))</div><div class="line">	fmt.Println(needFloat(Small))</div><div class="line">	fmt.Println(needFloat(Big))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><h4 id="for-go中只有一个循环语句，就是for"><a href="#for-go中只有一个循环语句，就是for" class="headerlink" title="for : go中只有一个循环语句，就是for"></a>for : go中只有一个循环语句，就是for</h4><p>for 语句没有了() ,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		sum += i</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="用for模仿while-continue"><a href="#用for模仿while-continue" class="headerlink" title="用for模仿while (continue)"></a>用for模仿while (continue)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	var i int</div><div class="line">	for ; sum &lt; 1000; &#123;</div><div class="line">		sum += sum</div><div class="line">		i += 1</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum, i) //1024 10 ,说明运行了10次，最后才大于1000</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 更简洁的写法</div><div class="line"></div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	for sum &lt; 1000 &#123;</div><div class="line">		sum += sum</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//死循环</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 1</div><div class="line">	for i := 0; i &lt; 10;  &#123; //这里没有退出条件，所以会死循环</div><div class="line">		sum += i</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 更简洁的死循环</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	for &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">if x &lt; 0 &#123;</div><div class="line">	return sqrt(-x) + &quot;i&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func pow(x, n, lim float64) float64 &#123;</div><div class="line">//if 可以先运行一段小代码，但是只拥有局部作用域</div><div class="line">	if v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">		return v</div><div class="line">	&#125;</div><div class="line">	//return v //会报错，提示没有这个变量</div><div class="line">	return lim</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(</div><div class="line">		pow(3, 2, 10),</div><div class="line">		pow(3, 3, 20),</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>if else ,在if中定义的变量，在else代码块中仍然有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func pow(x, n, lim float64) float64 &#123;</div><div class="line">	if v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">		return v</div><div class="line">	&#125; else &#123;</div><div class="line">		fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim)</div><div class="line">	&#125;</div><div class="line">	// can&apos;t use v here, though</div><div class="line">	return </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Print(&quot;Go runs on &quot;)</div><div class="line">	switch os := runtime.GOOS; os &#123; //先运行一小段代码，然后该变量在块中有效&#123;&#125;</div><div class="line">	case &quot;darwin&quot;:</div><div class="line">		fmt.Println(&quot;OS X.&quot;)</div><div class="line">	case &quot;linux&quot;:</div><div class="line">		fmt.Println(&quot;Linux.&quot;)</div><div class="line">	default:</div><div class="line">		// freebsd, openbsd,</div><div class="line">		// plan9, windows...</div><div class="line">		fmt.Printf(&quot;%s.&quot;, os)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//switch 里面的case可以运行小段代码后比较</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Print(&quot;Go runs on &quot;)</div><div class="line">	switch os := runtime.GOOS; os &#123;</div><div class="line">	case &quot;darwin&quot;:</div><div class="line">		fmt.Println(&quot;OS X.&quot;)</div><div class="line">	case &quot;linux&quot;:</div><div class="line">		fmt.Println(&quot;Linux.&quot;)</div><div class="line">	default:</div><div class="line">		// freebsd, openbsd,</div><div class="line">		// plan9, windows...</div><div class="line">		fmt.Printf(&quot;%s.&quot;, os)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>switch 代替长的if else链, 因为空的switch等于switch true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	t := time.Now()</div><div class="line">	switch &#123; //类似switch true ,当下面任何一个成立都会退出</div><div class="line">	case t.Hour() &lt; 12:</div><div class="line">		fmt.Println(&quot;Good morning!&quot;)</div><div class="line">	case t.Hour() &lt; 17:</div><div class="line">		fmt.Println(&quot;Good afternoon.&quot;)</div><div class="line">	default:</div><div class="line">		fmt.Println(&quot;Good evening.&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="defer-go中实现事情延时非常简洁-类似js的generate"><a href="#defer-go中实现事情延时非常简洁-类似js的generate" class="headerlink" title="defer go中实现事情延时非常简洁(类似js的generate)"></a>defer go中实现事情延时非常简洁(类似js的generate)</h4><p>虽然有了延时，只是延时到了所有任务执行完毕的下一个循环，但是没有js的手动启动它什么时候执行,由程序循环自动控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	defer fmt.Println(&quot;world&quot;)</div><div class="line"></div><div class="line">	fmt.Println(&quot;hello&quot;)</div><div class="line">	</div><div class="line">	defer fmt.Println(&quot;worl&quot;)</div><div class="line">	fmt.Println(&quot;helo&quot;)</div><div class="line"></div><div class="line">	//输出</div><div class="line">hello</div><div class="line">helo</div><div class="line">worl</div><div class="line">world</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>go 的defer 机制<br>遇到了defer关键字的，就先把该事件（语句）存放入一个栈，这个栈是先进后出原则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(&quot;counting&quot;)</div><div class="line"></div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		defer fmt.Println(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(&quot;done&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">9</div><div class="line">8</div><div class="line">7</div><div class="line">6</div><div class="line">5</div><div class="line">4</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h4 id="poiters-理解指针"><a href="#poiters-理解指针" class="headerlink" title="poiters, 理解指针"></a>poiters, 理解指针</h4><p>指针a是一个指向变量b的地址的变量，通过&amp;b 可以得到b的地址，通过*a 可以利用指针a来操作变量b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var p *int // 声明一个指向int类型的 指针</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func ch(t int) int &#123;</div><div class="line">	t = 33</div><div class="line">	return t</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	i, j := 42, 2701</div><div class="line"></div><div class="line">	p := &amp;i         // point to i //通过取i的地址，直接赋值给变量p</div><div class="line">	fmt.Println(*p) // read i through the pointer //通过指针操作符，*p,操作p所存地址的这个变量</div><div class="line">	*p = 88    // set i through the pointer</div><div class="line">	ch(*p)  //*p指针传值为对这个指针的复制 ,所以操作不会改变指针指向变量的值</div><div class="line">	t := *p //t是*p的一个复制</div><div class="line">	fmt.Println(i, t)  // see the new value of i</div><div class="line"></div><div class="line">	p = &amp;j         // point to j</div><div class="line">	*p = *p / 37   // divide j through the pointer</div><div class="line">	fmt.Println(j) // see the new value of j</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>彻底理解指针，变量就是一个地址加一个值，不管是什么东西，在内存中，都是一个地址，一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = 0 //变量a的值是0</div><div class="line">a += 5 //为什么直接调用a能改变a的值？因为默认了a就是拿到了a的值得存放地址，有了这个地址就可以操作a的值改变</div></pre></td></tr></table></figure></p>
<p>指针是一种间接操作，也就是先知道了某个变量的存放地址，那么知道了地址就要利用指针工具*来操纵它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">p := 8</div><div class="line">t := &amp;p //把p变量的存放地址赋值给t，也就是t的值是一个地址，（出于安全不可以改变t的值了，因为它的值是地址，但是t本身就是一个变量，也有它自己的地址）</div><div class="line">*t = 9 //t只能被指针操作符来操作了，也就是t的作用就是用来远程操作p，</div><div class="line">g := t //将g的值设置为t的值，也就是p的地址</div><div class="line">*g = 10 //同样可以远程操作到p</div><div class="line">g = 88 //会报错，因为g存放的是地址，不能改变了，只能传值,</div><div class="line">k := &amp;g // k变量保存为g的地址，但是g的值是p的地址，同理k的作用是远程操作g，而g的作用是远程操作p</div><div class="line">所以，只能用</div><div class="line">**k 来远程操作p，这里要看是什么用，记住地址为了安全，不能修改，只能赋值和远程操作</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 有关指针的完整例子，永远记得指针只是一个变量，只是有特殊标志，让人知道，只是在操作指针本身的值（地址）， 还是利用它操作它指向的地址的值</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 指针传值,因此可以实现改变内容，js中为引用传值，与这里实际上是一个道理，go/c中引用的概念相当于一个别名，并不是地址传值</div><div class="line">func cha(p *int) int &#123;</div><div class="line">	*p = 43432</div><div class="line">	return *p</div><div class="line">	&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	i, j := 42, 2701</div><div class="line"></div><div class="line">	p := &amp;i         // point to i</div><div class="line">	fmt.Println(*p) // read i through the pointer</div><div class="line">	*p = 21         // set i through the pointer</div><div class="line">	fmt.Println(i)  // see the new value of i</div><div class="line"></div><div class="line">	p = &amp;j         // point to j</div><div class="line">	*p = *p / 37   // divide j through the pointer</div><div class="line">	fmt.Println(j) // see the new value of j</div><div class="line">	</div><div class="line">	fmt.Println(cha(p), *p, j)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="go中复杂类型，如slice-array-map-等"><a href="#go中复杂类型，如slice-array-map-等" class="headerlink" title="go中复杂类型，如slice, array, map  等"></a>go中复杂类型，如slice, array, map  等</h5><p>结构体struct 用来更好的规划数据结构，但这非常节省内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	X int</div><div class="line">	Y int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(Vertex&#123;1, 2&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 指向struct的指针，默认不用*前置即可操作</div><div class="line">type Vertex struct &#123;</div><div class="line">	X int</div><div class="line">	Y int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	v := Vertex&#123;1, 2&#125; // 这个是type&#123;value&#125; 形式的，不同于前面value type ,而且是连着的</div><div class="line">	p := &amp;v</div><div class="line">	t := Vertex&#123;4, 6&#125; </div><div class="line">	p = &amp;t //指向struct的指针可以重新指向该类型的另一个地址</div><div class="line">	p.X = 1e9 //直接操作的就是指针</div><div class="line">	fmt.Println(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="array-数组是要有固定长度的"><a href="#array-数组是要有固定长度的" class="headerlink" title="array ,数组是要有固定长度的"></a>array ,数组是要有固定长度的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a [10]int</div><div class="line"></div><div class="line">var a [2]string</div><div class="line">a[0] = &quot;Hello&quot;</div><div class="line">a[1] = &quot;World&quot;</div><div class="line">fmt.Println(a[0], a[1])</div><div class="line"></div><div class="line">// 数组直接返回的是指针，而a[0] 是下一个指针,(记得指针是一种远程操纵，即代表是要操纵当然值(是一个地址)的值)</div></pre></td></tr></table></figure>
<h5 id="Slice是一种可变的“集合”-类似c中的动态数组-但比它要方便-应该是利用链表思维来实现的。-slice拥有长-length-度和容量-capacity-只有拥有长度才可以使用a-2-形式读取值，只有拥有容量，才可以切割a-b-cap-2-slice有特定的api来动态添加，操作-创建slice可以直接声明，声明加初始化，或者用make方法；"><a href="#Slice是一种可变的“集合”-类似c中的动态数组-但比它要方便-应该是利用链表思维来实现的。-slice拥有长-length-度和容量-capacity-只有拥有长度才可以使用a-2-形式读取值，只有拥有容量，才可以切割a-b-cap-2-slice有特定的api来动态添加，操作-创建slice可以直接声明，声明加初始化，或者用make方法；" class="headerlink" title="Slice是一种可变的“集合”, 类似c中的动态数组,但比它要方便,应该是利用链表思维来实现的。,slice拥有长(length)度和容量(capacity), 只有拥有长度才可以使用a[2]形式读取值，只有拥有容量，才可以切割a := b[:cap[2]], slice有特定的api来动态添加，操作; 创建slice可以直接声明，声明加初始化，或者用make方法；"></a>Slice是一种可变的“集合”, 类似c中的动态数组,但比它要方便,应该是利用链表思维来实现的。,slice拥有长(length)度和容量(capacity), 只有拥有长度才可以使用a[2]形式读取值，只有拥有容量，才可以切割a := b[:cap[2]], slice有特定的api来动态添加，操作; 创建slice可以直接声明，声明加初始化，或者用make方法；</h5><p>b := make([]int, 0, 5) // len(b)=0, cap(b)=5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//声明一个空slice : x []int //这个 slice长度和容量都是0</div><div class="line">//  声明一个非空slice必须先赋值</div><div class="line">s := []int&#123;2, 3, 5, 7, 11, 13&#125; // int类型的slice,与数组区别是，[len]不用表明，后面是初始值</div><div class="line"></div><div class="line">fmt.Println(&quot;s ==&quot;, s)</div><div class="line">fmt.Println(&quot;s[1:4] ==&quot;, s[1:4])</div><div class="line"></div><div class="line">// missing low index implies 0</div><div class="line">fmt.Println(&quot;s[:3] ==&quot;, s[:3])</div><div class="line"></div><div class="line">// missing high index implies len(s)</div><div class="line">fmt.Println(&quot;s[4:] ==&quot;, s[4:])</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// slice动态添加元素</div><div class="line">func main() &#123;</div><div class="line">	var s []int</div><div class="line">	printSlice(s)</div><div class="line"></div><div class="line">	// append works on nil slices.</div><div class="line">	s = append(s, 0)</div><div class="line">	printSlice(s)</div><div class="line"></div><div class="line">	// The slice grows as needed.</div><div class="line">	s = append(s, 1) // func append(s []T, vs ...T) []T</div><div class="line">	printSlice(s)</div><div class="line"></div><div class="line">	// We can add more than one element at a time.</div><div class="line">	s = append(s, 2, 3, 4)</div><div class="line">	printSlice(s)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func printSlice(s []int) &#123;</div><div class="line">	fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">for range 历遍一个 slice</div><div class="line"></div><div class="line">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	for i, v := range pow &#123;</div><div class="line">		fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 历遍slice需要得到它的index和value，当然可以更高效，只使用它的值</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	pow := make([]int, 10)</div><div class="line">	for i := range pow &#123;</div><div class="line">		pow[i] = 1 &lt;&lt; uint(i) // == 2**i</div><div class="line">	&#125;</div><div class="line">	for _, value := range pow &#123; //用_, 代表忽略index</div><div class="line">		fmt.Printf(&quot;%d\n&quot;, value)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 如果只要索引index</div><div class="line">	for i := range pow &#123;</div><div class="line">		fmt.Printf(i)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="复杂类型除了slice还有map-这两个是最基本的-slice可以动态添加，map也可以-创建map必须使用make方法"><a href="#复杂类型除了slice还有map-这两个是最基本的-slice可以动态添加，map也可以-创建map必须使用make方法" class="headerlink" title="复杂类型除了slice还有map  (这两个是最基本的),slice可以动态添加，map也可以,创建map必须使用make方法"></a>复杂类型除了slice还有map  (这两个是最基本的),slice可以动态添加，map也可以,创建map必须使用make方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var m map[string]Vertex //声明一个map ,其中要表明key, value的类型</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	m = make(map[string]Vertex) //实际上还是需要用make方法</div><div class="line">	m[&quot;Bell Labs&quot;] = Vertex&#123;</div><div class="line">		40.68433, -74.39967,</div><div class="line">	&#125;</div><div class="line">	fmt.Println(m[&quot;Bell Labs&quot;])</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	Lat, Long float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 以下却不用写make方法</div><div class="line">var m = map[string]Vertex&#123;</div><div class="line">	&quot;Bell Labs&quot;: Vertex&#123;</div><div class="line">		40.68433, -74.39967,</div><div class="line">	&#125;,</div><div class="line">	&quot;Google&quot;: Vertex&#123;</div><div class="line">		37.42202, -122.08408,</div><div class="line">	&#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="函数与闭包-函数可以作为值传过来，也可以使用闭包"><a href="#函数与闭包-函数可以作为值传过来，也可以使用闭包" class="headerlink" title="函数与闭包, 函数可以作为值传过来，也可以使用闭包"></a>函数与闭包, 函数可以作为值传过来，也可以使用闭包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func compute(fn func(float64, float64) float64) float64 &#123;</div><div class="line">	return fn(3, 4)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	hypot := func(x, y float64) float64 &#123;</div><div class="line">		return math.Sqrt(x*x + y*y)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(hypot(5, 12))</div><div class="line"></div><div class="line">	fmt.Println(compute(hypot))</div><div class="line">	fmt.Println(compute(math.Pow))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 闭包</div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func adder() func(int) int &#123;</div><div class="line">	sum := 0</div><div class="line">	return func(x int) int &#123;</div><div class="line">		sum += x</div><div class="line">		return sum</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	pos, neg := adder(), adder()</div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		fmt.Println(</div><div class="line">			pos(i),</div><div class="line">			neg(-2*i),</div><div class="line">		)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>操纵map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 有map m</div><div class="line">新增或者修改</div><div class="line">m[key] = value</div><div class="line"></div><div class="line">获取</div><div class="line">m[key]</div><div class="line"></div><div class="line">删除</div><div class="line">delete(m, key)</div><div class="line"></div><div class="line">测试map中是否有该key </div><div class="line"></div><div class="line">elem, ok := m[key]</div><div class="line">// 如果有ok为true,且elem等于该key的值</div></pre></td></tr></table></figure>
<h4 id="go中的面向对象"><a href="#go中的面向对象" class="headerlink" title="go中的面向对象"></a>go中的面向对象</h4><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>go 的面向对象是基于结构体的（struct），结构体本来只有变量，但是应该把函数也看做变量，即把新定义的方法（函数）发送到struct中，然后它接收就可以实现了方法和变量同在，也就是类了。</p>
<p>类的成员有属性与方法，属性是每个类都独立的，而方法是每个类共有的，go中有种机制，可以用strut 定义类中所有属性，然后利用类似接收者机制，把一个方法归结到stuct中使用，合成了一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	X, Y float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func Abs(v Vertex) float64 &#123;  //普通函数,传入一个v, (复制传值)</div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v Vertex) Abs() float64 &#123; // 类的方法(区别于普通函数，因为它显式表明了接收者是Vertex类型的v，)</div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	v := Vertex&#123;3, 4&#125;</div><div class="line">	fmt.Println(Abs(v))</div><div class="line">	v := Vertex&#123;3, 4&#125;</div><div class="line">	fmt.Println(v.Abs())</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 不管是函数形式还是接收者形式实现“类”，都要利用指针，以便可以直接修改值，和实现更高的效率，（不用复制一份）</div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Vertex struct &#123;</div><div class="line">	X, Y float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v *Vertex) Scale(f float64) &#123; //类的方法</div><div class="line">	v.X = v.X * f //sturct中使用指针不用前置 *</div><div class="line">	v.Y = v.Y * f</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v *Vertex) Abs() float64 &#123; </div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	v := &amp;Vertex&#123;3, 4&#125;</div><div class="line">	fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</div><div class="line">	v.Scale(5)</div><div class="line">	fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口其实就是换装，即把不同名称的类，（但这些类有共同的方法）附加到接口中，或者反过来说，就是定义接口，然后用不同的类实现它.</p>
<p>go 中的接口实现与go中实现类的方法类似，定义接口时，只需定义接口存在的方法，然后直接让该接口等于任何一个实现了这个方法的类即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type Abser interface &#123; // 声明一个接口</div><div class="line">	Abs() float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var a Abser //声明一个接口值</div><div class="line">	f := MyFloat(-math.Sqrt2)</div><div class="line">	v := Vertex&#123;3, 4&#125;</div><div class="line"></div><div class="line">	a = f  // a MyFloat implements Abser //使用接口实现即使直接赋值</div><div class="line">	a = &amp;v // a *Vertex implements Abser //如果实现方法利用指针就要传地址</div><div class="line"></div><div class="line">	// In the following line, v is a Vertex (not *Vertex)</div><div class="line">	// and does NOT implement Abser.</div><div class="line">	//a = v</div><div class="line"></div><div class="line">	fmt.Println(a.Abs())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接口实现极为简单（思维当作js中的标识型实现接口）, 只需要在类中有这个方法(实现这个方法)即可</div><div class="line">type MyFloat float64</div><div class="line"></div><div class="line">func (f MyFloat) Abs() float64 &#123;</div><div class="line">	if f &lt; 0 &#123;</div><div class="line">		return float64(-f)</div><div class="line">	&#125;</div><div class="line">	return float64(f)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这里也是同理,书写接口实现就是写一个类</div><div class="line">type Vertex struct &#123;</div><div class="line">	X, Y float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (v *Vertex) Abs() float64 &#123;</div><div class="line">	return math.Sqrt(v.X*v.X + v.Y*v.Y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">空接口</div><div class="line"></div><div class="line"></div><div class="line">type I interface &#123;</div><div class="line">	M()</div><div class="line">&#125;</div><div class="line"></div><div class="line">type T struct &#123;</div><div class="line">	S string</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *T) M() &#123;</div><div class="line">	if t == nil &#123;</div><div class="line">		fmt.Println(&quot;&lt;nil&gt;&quot;)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	fmt.Println(t.S)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i I</div><div class="line"></div><div class="line">	var t *T</div><div class="line">	i = t</div><div class="line">	describe(i)</div><div class="line">	i.M()</div><div class="line"></div><div class="line">	i = &amp;T&#123;&quot;hello&quot;&#125;</div><div class="line">	describe(i)</div><div class="line">	i.M()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func describe(i I) &#123;</div><div class="line">	fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 空接口可以包含任何值</div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i interface&#123;&#125; // 这里是一个空接口</div><div class="line">	describe(i)</div><div class="line"></div><div class="line">	i = 42</div><div class="line">	describe(i)</div><div class="line"></div><div class="line">	i = &quot;hello&quot;</div><div class="line">	describe(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func describe(i interface&#123;&#125;) &#123;</div><div class="line">	fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口类型判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	var i interface&#123;&#125; = &quot;hello&quot;</div><div class="line"></div><div class="line">	s := i.(string) //判断接口是不是string类型</div><div class="line">	fmt.Println(s)</div><div class="line"></div><div class="line">	s, ok := i.(string)</div><div class="line">	fmt.Println(s, ok)</div><div class="line"></div><div class="line">	f, ok := i.(float64)</div><div class="line">	fmt.Println(f, ok)</div><div class="line"></div><div class="line">	f = i.(float64) // panic</div><div class="line">	fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>string类型有许多内置方法，如打印时，默认是调用String()方法来输出打印行为，如果实现该接口，那么可以自定义打印输出行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type Person struct &#123;</div><div class="line">	Name string</div><div class="line">	Age  int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (p Person) String() string &#123;</div><div class="line">	return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;</div><div class="line">	z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;</div><div class="line">	fmt.Println(a, z)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="错误处理，类似stinger-每个操作go中都有错误处理接口，只要实现-了自己的错误处理方法，就可以使用自己的方法来处理错误"><a href="#错误处理，类似stinger-每个操作go中都有错误处理接口，只要实现-了自己的错误处理方法，就可以使用自己的方法来处理错误" class="headerlink" title="错误处理，类似stinger, 每个操作go中都有错误处理接口，只要实现 了自己的错误处理方法，就可以使用自己的方法来处理错误"></a>错误处理，类似stinger, 每个操作go中都有错误处理接口，只要实现 了自己的错误处理方法，就可以使用自己的方法来处理错误</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type MyError struct &#123;</div><div class="line">	When time.Time</div><div class="line">	What string</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (e *MyError) Error() string &#123;</div><div class="line">	return fmt.Sprintf(&quot;at %v, %s&quot;,</div><div class="line">		e.When, e.What)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func run() error &#123;</div><div class="line">	return &amp;MyError&#123;</div><div class="line">		time.Now(),</div><div class="line">		&quot;it didn&apos;t work&quot;,</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	if err := run(); err != nil &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="go-goroutine"><a href="#go-goroutine" class="headerlink" title="go goroutine"></a>go goroutine</h5><p>go中的协程，是一种超级轻量化的协程，宏观工作方式类似进程，即运行协程后，协程会在跟当前协程平行的协程中独立运行，(但却可以共享内存), 如果新的独立协程有异步行动，当前协程需要用到，那么当前协程会像同步进程一样等待。但是如果同时创建多条新的协程，这多条协程之间是独立，并且互相平行工作</p>
<p>协程之间通过chanel + 管道来通信，想象每个协程是独立的一个人，然后回监听一条或者多条管道，如果管道有内容过来，就开始特定的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func sum(a []int, c chan int) &#123;</div><div class="line">	sum := 0</div><div class="line">	for _, v := range a &#123;</div><div class="line">		sum += v</div><div class="line">	&#125;</div><div class="line">	c &lt;- sum // 将和送入 管道c</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	a := []int&#123;7, 2, 8, -9, 4, 0&#125;</div><div class="line"></div><div class="line">	c := make(chan int) // 声明一个管道</div><div class="line">	go sum(a[:len(a)/2], c) //协程独立运行,并往下</div><div class="line">	go sum(a[len(a)/2:], c) //协程独立运行,并往下</div><div class="line">	go fmt.Println(&quot;t&quot;) //协程独立运行,因为这个比较快，会先得到返回，</div><div class="line">	x, y := &lt;-c, &lt;-c // 从 c 中获取 //后面的必须等待前面所有协程运行完毕才执行,因为管道的另一端没有准备好，会阻塞</div><div class="line"></div><div class="line">	fmt.Println(x, y, x+y)</div><div class="line">	fmt.Println(434)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func fibonacci(n int, c chan int) &#123;</div><div class="line">	x, y := 0, 1</div><div class="line">	for i := 0; i &lt; n; i++ &#123;</div><div class="line">		c &lt;- x</div><div class="line">		x, y = y, x+y</div><div class="line">	&#125;</div><div class="line">	close(c) //先是不断向管道中送数据，最后发送一个结束信号</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	c := make(chan int, 10)</div><div class="line">	go fibonacci(cap(c), c) //抛出一条新的协程,独立工作，程序往下执行</div><div class="line">	for i := range c &#123;  //不断从管道中抽取内容, 直到结束</div><div class="line">		fmt.Println(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(&apos;test order&apos;) //最后运行，因为前面的没有完全运行完</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func fibonacci(c, quit chan int) &#123;</div><div class="line">	x, y := 0, 1</div><div class="line">	for &#123; //不断循环，但是当条件不满足时，会阻塞</div><div class="line">		select &#123;</div><div class="line">		case c &lt;- x:  //如果可以往管道中送入x值，就执行它</div><div class="line">			x, y = y, x+y</div><div class="line">		case &lt;-quit: //如果能从管道quit中取出值，就执行它</div><div class="line">			fmt.Println(&quot;quit&quot;)</div><div class="line">			return // 结束for循环</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	c := make(chan int)</div><div class="line">	quit := make(chan int)</div><div class="line">	go func() &#123; //抛出协程，独立工作，往下 执行</div><div class="line">		for i := 0; i &lt; 10; i++ &#123;</div><div class="line">			fmt.Println(&lt;-c) //这个协程不断读取c管道值十次,一般情况下发送和读取时配套的，所以fibonacci协程会在十次之后不向c管道发送内容了</div><div class="line">		&#125;</div><div class="line">		quit &lt;- 1</div><div class="line">	&#125;()</div><div class="line">	fibonacci(c, quit)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 锁，控制某一个值同一时刻只被一个协程访问</div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;sync&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// SafeCounter 的并发使用是安全的。</div><div class="line">type SafeCounter struct &#123;</div><div class="line">	v   map[string]int</div><div class="line">	mux sync.Mutex</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Inc 增加给定 key 的计数器的值。,类的方法</div><div class="line">func (c *SafeCounter) Inc(key string) &#123;</div><div class="line">	//c.mux.Lock()</div><div class="line">	// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</div><div class="line">	c.v[key]++</div><div class="line">	//c.mux.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Value 返回给定 key 的计数器的当前值。</div><div class="line">func (c *SafeCounter) Value(key string) int &#123;</div><div class="line">	//c.mux.Lock()</div><div class="line">	// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</div><div class="line">	defer c.mux.Unlock() //用defer保证一定会被解锁</div><div class="line">	return c.v[key]</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	c := SafeCounter&#123;v: make(map[string]int)&#125;</div><div class="line">	for i := 0; i &lt; 1000; i++ &#123;</div><div class="line">		go c.Inc(&quot;somekey&quot;) //并发1000个协程</div><div class="line">		//fmt.Println(44)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	time.Sleep(time.Second)</div><div class="line">	fmt.Println(c.Value(&quot;somekey&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/goGramer/" data-id="cizut7q2w000it4ddlunj3nbn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/go/" class="article-date">
  <time datetime="2017-03-03T11:20:16.278Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/03/go/">golang learning</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="go-是google-出品的一个真正编译性语言，它的速度很快，可以媲美c，c-，当然，还有原生的支持多并发，所以可以说是nodejs的强大对手，还有许多很现代化的功能，或者说是完全的各个语言集合的强大语言"><a href="#go-是google-出品的一个真正编译性语言，它的速度很快，可以媲美c，c-，当然，还有原生的支持多并发，所以可以说是nodejs的强大对手，还有许多很现代化的功能，或者说是完全的各个语言集合的强大语言" class="headerlink" title="go 是google 出品的一个真正编译性语言，它的速度很快，可以媲美c，c++，当然，还有原生的支持多并发，所以可以说是nodejs的强大对手，还有许多很现代化的功能，或者说是完全的各个语言集合的强大语言"></a>go 是google 出品的一个真正编译性语言，它的速度很快，可以媲美c，c++，当然，还有原生的支持多并发，所以可以说是nodejs的强大对手，还有许多很现代化的功能，或者说是完全的各个语言集合的强大语言</h3><hr>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// package.go  文件名</div><div class="line">package main // 每个文件就是一个包，这是包名</div><div class="line"></div><div class="line">import (   //要引入的包名 ,在本包中，能使用的只是这里引入的包，其他未引入的包不能使用</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math/rand&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123; // 每个包都有主函数，类似c中的</div><div class="line">	fmt.Println(&quot;My favorite number is&quot;, rand.Intn(10))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main //包名</div><div class="line"></div><div class="line">import &quot;fmt&quot; //引入的包，用&quot;&quot; ,字符串用&quot;&quot;  ,如果引入包但未使用，会发生错误</div><div class="line"></div><div class="line">func add(x int, y int) int &#123; // 变量类型需要声明在变量后面，函数返回值类型声明在func 后 ,也可以x, y int</div><div class="line">	return x + y  </div><div class="line">&#125;</div><div class="line">//声明多个变量</div><div class="line">// var i int 或  var c, python, js bool </div><div class="line">//变量初始化</div><div class="line">var i, j = 1, 2 // 当有初始化的时候，就不需要声明变量类型</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(add(42, 13))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 声明后返回值</div><div class="line"></div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func split(sum int) (x, y int) &#123; // 此处已经声明返回的是两个int类型的值</div><div class="line">	x = sum * 4 / 9</div><div class="line">	y = sum - x</div><div class="line">	return</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(split(17))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">var i, j int = 1, 2  //在函数外面，变量声明都要以var开头,但在函数里面，可以用 := 代替</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	k := 3 //如上所述 </div><div class="line">	var c, python, java = true, false, &quot;no!&quot;</div><div class="line">	fmt.Println(i, j, c, python, java)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="常规变量类型"><a href="#常规变量类型" class="headerlink" title="常规变量类型"></a>常规变量类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">bool</div><div class="line"></div><div class="line">string // &quot;&quot;</div><div class="line"></div><div class="line">int  int8  int16  int32  int64 //整数，分别用n位二进制表示，注意溢出问题，就是所保存数不能大于2的n次方 ,其中int 的位数和电脑有关，32位系统，就是32位，64位就是64</div><div class="line">uint uint8 uint16 uint32 uint64 uintptr //存二进制，unit 位数与系统有关</div><div class="line"></div><div class="line">byte // alias for uint8</div><div class="line"></div><div class="line">rune // alias for int32</div><div class="line">     // represents a Unicode code point</div><div class="line"></div><div class="line">float32 float64</div><div class="line"></div><div class="line">complex64 complex128</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math/cmplx&quot;</div><div class="line">)</div><div class="line"></div><div class="line">var (</div><div class="line">	ToBe   bool       = false</div><div class="line">	MaxInt uint8     = 8&lt;&lt;3 - 1  //左移后会变大，如果移位后得到的值大于unit8所能容纳的最大值，将会有溢出错误</div><div class="line">	z      complex128 = cmplx.Sqrt(-5 + 12i)</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	const f = &quot;%T(%v)\n&quot;</div><div class="line">	fmt.Printf(f, ToBe, ToBe)</div><div class="line">	fmt.Printf(f, MaxInt, MaxInt)</div><div class="line">	fmt.Printf(f, z, z)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 变量初始化如果没有显示初始化explicit</div><div class="line"></div><div class="line">0 for numeric types, //0 ,数字型的包括int float等</div><div class="line">false the boolean type, and</div><div class="line">&quot;&quot; (the empty string) for strings.</div><div class="line">// 变量如果有初始化，那么变量类型就视初始化给的值而定</div><div class="line"></div><div class="line">///静态值</div><div class="line">	const Pi = 3.14 //静态值不可以 := </div><div class="line"></div><div class="line">// const 类型的可以储存高精度的数字</div><div class="line">const (</div><div class="line">	Big   = 1 &lt;&lt; 100</div><div class="line">	Small = Big &gt;&gt; 99</div><div class="line">)</div><div class="line"></div><div class="line">func needInt(x int) int &#123; return x*10 + 1 &#125;</div><div class="line">func needFloat(x float64) float64 &#123;</div><div class="line">	return x * 0.1</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(needInt(Small))</div><div class="line">	fmt.Println(needFloat(Small))</div><div class="line">	fmt.Println(needFloat(Big))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var i int = 42</div><div class="line">var f float64 = float64(i)</div><div class="line">var u uint = uint(f)</div><div class="line"></div><div class="line">Or, put more simply:</div><div class="line"></div><div class="line">i := 42</div><div class="line">f := float64(i)</div><div class="line">u := uint(f)</div></pre></td></tr></table></figure>
<h3 id="循环，只有-for"><a href="#循环，只有-for" class="headerlink" title="循环，只有 for"></a>循环，只有 for</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	sum := 0</div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		sum += i</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 可以放空前后</div><div class="line">for ; sum &lt; 1000; &#123;</div><div class="line">		sum += sum</div><div class="line">	&#125;</div><div class="line"></div><div class="line">// while 用 for 替代</div><div class="line"></div><div class="line">    sum := 1</div><div class="line">	for sum &lt; 1000 &#123;</div><div class="line">		sum += sum</div><div class="line">	&#125;</div><div class="line">	fmt.Println(sum)</div><div class="line">//无限循环	</div><div class="line">	for &#123;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="if-和-else-if后面声明的新变量和新短语句可以在-else中使用，但不可以在if-else-外使用"><a href="#if-和-else-if后面声明的新变量和新短语句可以在-else中使用，但不可以在if-else-外使用" class="headerlink" title="if 和 else ,if后面声明的新变量和新短语句可以在 else中使用，但不可以在if else 外使用"></a>if 和 else ,if后面声明的新变量和新短语句可以在 else中使用，但不可以在if else 外使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func pow(x, n, lim float64) float64 &#123;</div><div class="line">	if v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">		return v</div><div class="line">	&#125; else &#123;</div><div class="line">		fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim)</div><div class="line">	&#125;</div><div class="line">	// can&apos;t use v here, though</div><div class="line">	return </div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(</div><div class="line">		pow(3, 2, 10),  //两个pow的调用比Println 先，时同时运行的</div><div class="line">		pow(3, 3, 20),</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/go/" data-id="cizut7q3i000vt4ddj2sm79pr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/git/" class="article-date">
  <time datetime="2017-03-03T11:20:16.275Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title: git  的用法</p>
<ol>
<li>apt-get install git </li>
<li>配置本地的git用户名与邮箱，git config –global user.name “Your Name”<br>$ git config –global user.email “email@example.com”</li>
<li>mkdir new ,cd new ,</li>
<li>git init , 在当期目录下新建空仓库</li>
<li>git add foo.txt , git add foo/* ,  添加一些东西到缓存区<br> 5.1 git rm –cache /path to file/ ,删除缓冲区文件<br> 5.2 git rm -f /path/ ,先删除缓存，还会从物理中删除<br> 5.3 touch 创建文件<br> 5.4 -f 是强制，-r是递归删除</li>
<li>git status ,查看现在缓存区的状态，知道是否已经提交到工作区</li>
<li>git commit -m ‘some discription’; 正式提交到工作区，得到了一个新版本</li>
<li>git log 查看各个版本,最后的版本在上</li>
<li>重复以上git add ,git commit ，得到2版本，</li>
<li>git reset commit_id ,将版本恢复到某个，可以在git log  中查看,其中HEAD 代表最新版本，HEAD~,代表最新开始倒数第二个，</li>
<li>git remote add origin git@github.com:lumingliang/l5_good.git ,添加origin(当前状态)与远程 配对<br>git push -u origin master, 将origin传到远程<br>//用 ssh ，将东西推送到github</li>
<li>注意，ssh ,将已有或者新建的公玥传到github ,的ssh中，实现无密码传送</li>
<li><p>git remote remove foo ,删除某个remote;</p>
</li>
<li><p>git remote查看有多什么remote, git remote -v 显示更详细</p>
</li>
</ol>
<h4 id="每次提交的版本就像一条时间线，每一次提交，时间线就向前走一步，而master主分支就指向当前的最新点，如果创建了其他dev分支，那么该分支会创建一个指向当前的指针，切换到该dev分支，后面的提交都是只对该指针有效，dev会向前，但是master不会。直到合并后，才会。"><a href="#每次提交的版本就像一条时间线，每一次提交，时间线就向前走一步，而master主分支就指向当前的最新点，如果创建了其他dev分支，那么该分支会创建一个指向当前的指针，切换到该dev分支，后面的提交都是只对该指针有效，dev会向前，但是master不会。直到合并后，才会。" class="headerlink" title="每次提交的版本就像一条时间线，每一次提交，时间线就向前走一步，而master主分支就指向当前的最新点，如果创建了其他dev分支，那么该分支会创建一个指向当前的指针，切换到该dev分支，后面的提交都是只对该指针有效，dev会向前，但是master不会。直到合并后，才会。"></a>每次提交的版本就像一条时间线，每一次提交，时间线就向前走一步，而master主分支就指向当前的最新点，如果创建了其他dev分支，那么该分支会创建一个指向当前的指针，切换到该dev分支，后面的提交都是只对该指针有效，dev会向前，但是master不会。直到合并后，才会。</h4><ol>
<li>git branch 查看当前所在分支</li>
<li>git branch <name> 创建分支</name></li>
<li>git checkout <name> 切换分支</name></li>
<li>git checkout -b <name> 创建并切换分支</name></li>
<li>git merge <name> 合并某分支到当前(一般切换到master把dev分支合并到master)</name></li>
<li>git branch -d <name> 删除分支</name></li>
</ol>
<h4 id="但是当主分支和dev都有新的提交时，合并就会有冲突，git会支出两次提交的不同内容"><a href="#但是当主分支和dev都有新的提交时，合并就会有冲突，git会支出两次提交的不同内容" class="headerlink" title="但是当主分支和dev都有新的提交时，合并就会有冲突，git会支出两次提交的不同内容"></a>但是当主分支和dev都有新的提交时，合并就会有冲突，git会支出两次提交的不同内容</h4><ol>
<li>git status会看到合并失败的信息，(two branch are both modified),这时候可以查看该冲突文件内容，会看到git的标志，修改后，再合并，git会以当前修改的版本为基准合并，git log可以看到合并图</li>
</ol>
<h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p>多人协作是多人一起在同一个分支或不同分支开发，然后都可以用pull看到对方的代码，就像有个自动的代码更新一样，你只需要提交自己的更新，然后解决冲突，最后把所有合并到master,基本步骤如下。</p>
<ol>
<li>有个原始的master, 在master上创建dev分支，A :git clone得到该master分支，如果A的密钥跟远程origin()的对口，那么就可以用git remote -v查看推送权限</li>
<li>A有了推送权限后，可以用git checkout -b deb origin/dev 创建本地的dev分支对应远程的origin/dev 分支，当修改后，commit再push到origin即可</li>
<li>如果push不成功，那么就是有文件的提交跟origin dev的最新提交冲突，需要pull下来解决冲突再提交</li>
<li>git pull,(如果失败，说明没有建立本地dev到远程 origin/dev的链接),git branch –set -upstream dev origin/dev来创建,这时再git pull就成功了，</li>
<li>pull回来之后，需要解决冲突，方法是，打开本地冲突文件，就会标志出冲突地方，然后修改，最后git commit -m “merge &amp; fix conflit hello.py”后，再push 这样就可以了<br>缓存区 =&gt; 工作区 是git管理，而源码只有一个状态，可以用git来实现对源码与缓存区，缓存区与工作区间的同步,远程提交，只提交源码，缓存区与工作区用来进行版本管理与还原</li>
</ol>
<p>缓存区监控源码修改，如果源码修改了没有放入缓存区，缓存区会显示没有更新,</p>
<h5 id="版本还原"><a href="#版本还原" class="headerlink" title="版本还原"></a>版本还原</h5><ol>
<li>git reset HEAD^ 将工作区的版本还原为上一个版本，这时源码没有改变，只是工作区保存的版本变少了，此时缓存区显示当前修改没有提交，这里就相当于没有执行git commit一样,有利于远程提交，因为远程提交的是工作区里面的最新版本，并不是当前源码<br>(1) 回退所有内容到上一个版本<br>git reset HEAD^<br>(2) 回退a.py这个文件的版本到上一个版本<br>git reset HEAD^ a.py<br>(3) 向前回退到第3个版本<br>git reset –soft HEAD~3<br>(4) 将本地的状态回退到和远程的一样<br>git reset –hard origin/master<br>(5) 回退到某个版本<br>git reset 057d<br>(7) 回退到上一次提交的状态，按照某一次的commit完全反向的进行一次commit<br>git revert HEAD   </li>
</ol>
<p> git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息</p>
<pre><code>git reset --soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可

git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容
</code></pre><ol>
<li>如果要实现源码还原需要用git reset –hard git_log_id(git log后复制id即可)</li>
</ol>
<h3 id="设置终端"><a href="#设置终端" class="headerlink" title="设置终端"></a>设置终端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 先清除掉.ssh目录下的钥匙,*(为了创建默认，如果技术成熟也可以用新的名)</div><div class="line">//在默认~/.ssh/下创建默认的钥匙</div><div class="line">ssh-keygen -t rsa -C &quot;angelen10@163.com&quot;</div><div class="line">//运行ssh代理</div><div class="line">eval &quot;$(ssh-agent -s)&quot;</div><div class="line">//添加钥匙到代理</div><div class="line">ssh-add ~/.ssh/id_rsa</div><div class="line">//应该是利用代理后台运作，当运行ssh时，会自动搜寻该钥匙并给服务端验证</div><div class="line"></div><div class="line">//当然别忘了</div><div class="line"> clip &lt; ~/.ssh/id_rsa.pub</div><div class="line"> //复制钥匙到剪切板，后粘贴到github指定地方</div></pre></td></tr></table></figure>
<h3 id="部署hexo项目到github-io-需要注意以下"><a href="#部署hexo项目到github-io-需要注意以下" class="headerlink" title="部署hexo项目到github.io,需要注意以下"></a>部署hexo项目到github.io,需要注意以下</h3><ol>
<li><p>_config.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@github.com:lumingliang/lumingliang.github.io.git</div><div class="line">  branch: master</div><div class="line">  //注意空格</div></pre></td></tr></table></figure>
</li>
<li><p>每个账户只有一个github.io网站，该项目下的文件夹作为链接分页，每个文件夹下都有一个index.html,以达到url跳转</p>
</li>
</ol>
<h4 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h4><h5 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h5><p>实际上，本地与远程是分离的，但是本地能push到远程，前提是本地的所有东西必须先进于远程。</p>
<p>有两种情况，远程有些文件新于本地，本地也有先于远程的东西，那么应该做的是：<br>先git pull [‘这里是该origin,一个本地可以拥有多个origin,但是没必要’], [master, 远程的分支] [master, /本地的分支];</p>
<p>pull后提示有没有冲突，说明远程的所有文件已经在本地存在了，那么再commit一遍，于是本地的状态是有远程的所有东西。 就可以push了</p>
<p>还有一种情况，本地保留的版本是前天的，但是昨天有人修改了并push该文件到远程，今天我修改了并尝试push，这时就会push不上，解决方法是，pull一下，然后回提示哪些文件需要解决冲突。接着进入该文件，就会标识有冲突的地方，这样只要再改一下并add, commit即可push </p>
<h5 id="git-比较提交前后的异同"><a href="#git-比较提交前后的异同" class="headerlink" title="git 比较提交前后的异同"></a>git 比较提交前后的异同</h5><p>进入目录 git diff 后可以看出哪个文件改了</p>
<p>git status 可以看出哪个文件改了没有提交<br>git checkout – file 可以撤销这次对某个文件的更改</p>
<h5 id="git-进阶"><a href="#git-进阶" class="headerlink" title="git 进阶"></a>git 进阶</h5><ol>
<li>建立分支 git branch ( 查看所有分支，* 是目前指向的分支 ), git branch branchName 创建一个新的分支 </li>
<li>git checkout branchName 切换到某一个分支，</li>
<li>git checkout commitName  版本回退到某一个commit</li>
<li>git checkout -b branchName 创建并切换到该新分支</li>
<li><p>git reset (HAED|commitName|branchName) fileName 将某个文件撤出stag缓存区, 进入缓存区的文件，即使后来删了工作区的对应文件，还是会随着commit 提交到版本库中</p>
</li>
<li><p>一般删除一个文件，需要先git rm (-f) fileName 撤销跟踪，再删除rm<br> git rm –cached fileName 仅从git仓库中删除</p>
</li>
<li>git log –pretty=format:”%h %s” –graph 查看分支情况<br> git lg</li>
<li>git merg 分支合并</li>
<li>git reset haed // 将暂存区中的内容回退到上一个版本，工作区内容没有变化,对应git add , git reset commitName 后haed 会指向该commmit</li>
<li>git reset –hard commitName 可以直接将本地的工作区和commit回退到该commmit, 并丢弃前面的commit</li>
</ol>
<p>git log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset’ –abbrev-commit –date=relative</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/git/" data-id="cizut7q2o000ft4ddthcmzgo3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/express/" class="article-date">
  <time datetime="2017-03-03T11:20:16.274Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/03/express/">express框架的深入理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="从一个最简单的服务器开始，服务器的根本就是传入请求，分析请求，调用本地资源，返回客户端"><a href="#从一个最简单的服务器开始，服务器的根本就是传入请求，分析请求，调用本地资源，返回客户端" class="headerlink" title="从一个最简单的服务器开始，服务器的根本就是传入请求，分析请求，调用本地资源，返回客户端"></a>从一个最简单的服务器开始，服务器的根本就是传入请求，分析请求，调用本地资源，返回客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 引入所需模块  </div><div class="line">var http = require(&quot;http&quot;);  </div><div class="line">var t = &apos;&apos;; //用全局变量保存每个不同客户端的信息，用特定的隐藏域与客户端交换通信，认清哪个是该客户端</div><div class="line">   </div><div class="line">// 建立服务器  </div><div class="line">var app = http.createServer(function(request, response) &#123;  </div><div class="line">// 创建answer变量  </div><div class="line">    var answer = &quot;&quot;; //用私有变量，实现每一个请求的内部不同逻辑 </div><div class="line">    answer += &quot;Request URL: &quot; + request.url + &quot;\n&quot;;  </div><div class="line">    answer += &quot;Request type: &quot; + request.method + &quot;\n&quot;;  </div><div class="line">    answer += &quot;Request headers: &quot; + JSON.stringify(request.headers) + &quot;\n&quot;;  </div><div class="line">   </div><div class="line">	t += &apos;add jj&apos; + request.url;</div><div class="line">    // 返回结果  </div><div class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  </div><div class="line">    response.end(answer+t);  </div><div class="line">&#125;);  </div><div class="line">   </div><div class="line">// 启动服务器  </div><div class="line">app.listen(1337, &quot;localhost&quot;);  </div><div class="line">console.log(&quot;Server running at http://localhost:1337/&quot;);</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/express/" data-id="cizut7q3p000yt4dd8mrtc23s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-filling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/filling/" class="article-date">
  <time datetime="2017-03-03T11:20:16.274Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/03/filling/">记录身体自损情况</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2016.7.3 (7.1 开始有感，7.2 看，7.3动作)<br>后有感</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/filling/" data-id="cizut7q2l000dt4dd33rigi2k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-encode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/encode/" class="article-date">
  <time datetime="2017-03-03T11:20:16.273Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="讲述有关编码的问题"><a href="#讲述有关编码的问题" class="headerlink" title="讲述有关编码的问题"></a>讲述有关编码的问题</h3><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><p>计算机只能处理数字，如果需要处理文本，必须把文本转化为数字，8位一个bytes,共有0到255个整数，就可以利用这255个整数表示255个字符，最初ASCII表示所有英文字母和一些符号，（编译器，电脑知道什么时候这些整数表示真正的数字，什么时候代表符号）</p>
<p>字符’0’和 数字0是不一样的</p>
<p>‘A’在ASCII中十进制是65，二进制是01000001, 但是 Unicode是十六位，因此，聪明的办法是Unicode中再前面补0来表示A,补8个0;但是这样会浪费内存，于是动态长度的UTF8出现了，即常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p>
<p>UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。如：用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p>
<h3 id="nodejs只支持utf-8编码-对于node-js-buffer流编码转换问题"><a href="#nodejs只支持utf-8编码-对于node-js-buffer流编码转换问题" class="headerlink" title="nodejs只支持utf-8编码,对于node js buffer流编码转换问题"></a>nodejs只支持utf-8编码,对于node js buffer流编码转换问题</h3><p><a href="https://segmentfault.com/a/1190000002787763" target="_blank" rel="external">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/encode/" data-id="cizut7q2t000ht4ddb1kkpjh1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-englishCache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/englishCache/" class="article-date">
  <time datetime="2017-03-03T11:20:16.273Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The 2011 EU Common Agricultural Policy aims to strengthen the competitiveness of the agricultural sector, to promote innovation, contribute to environmental protection and to support jobs and growth inrural areas. The consecutive reforms in agricultural policy have created adequate environment for developing and implementing innovative, environmentally friendly farming methods, allowing the farmers to increase the production and manage the local environment, which is essential for the sustainable development of the agricultural sector.</p>
<p>In this paper, wireless sensor network architecture for vegetable greenhouse is proposed in order to achieve scientific cultivation and lower management costs from the aspect of environmental monitoring.According to the analysis of the features of greenhouse environment, a practical and low-cost green-house monitoring system is designed based on wireless sensor network technology in order to monitor key environmental parameters such as the temperature, humidity and illumination.</p>
<p>key words: architeture<br>]<br>Precision agriculture can be defined as the art and science of using advanced technology to enhance crop production. Wireless sensor network (WSN) technologies are the major driver of the development of precision agriculture. Recent advances in wireless communications and electronics have enabled the development and production of low-cost, low-power and multi-functional sensors that are small in size and communicate in short distances.Cheap, smart sensors, networked through wireless links and deployed in large numbers, provide enormous opportunities for monitoring and controlling homes, cities and the environment(Vieira et al., 2003). WSNs as a contemporary technology, integrate the capabilities of sensors, automation control, digital network transmission, information storage and information processing (Yicket al., 2008)</p>
<p> The development of WSNs applications in precision agriculture (Brooke et al., 2003) and the system platform for data acquisition, validation, processing and visualization (Cao et al.,2008) makes it possible to increase efficiency, productivity and profitability while minimizing unintended impacts on wildlife and the environment in many agricultural production systems.</p>
<p>Various measurable physical, chemical and microbiological properties may be collected by a network of spatially distributed devices, available during the entire cropping season. Actually, the use of WSNs provides monitoring, acquisition and storage of various measured parameters. The stored data may be used for developing control and optimization strategies for crop production.Also, the collected data may be used for studying the inter-temporal variability of environmental impacts, which is especially important for conversion of conventional towards organic and sustainable crop production (Hokozono et al., 2012). Real time monitoring by implementation of WSNs contributes to minimiza-tion of potential production risks, emerging mainly from environmental  influences  and  human  actions  (Wu  et  al.,  2013).Furthermore, real time data from the fields may be used by farmersto help them adjust their crop production strategies at any time,without the need to use a tractor or any other vehicle to get to eachsampling point.</p>
<p> Therefore, the implementation of WSNs contributes to some extent to the decrease of energy consumption in agriculture, bearing in mind that the current cropping systems are usually related to high fossil energy input (Di Nasso et al., 2011)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/englishCache/" data-id="cizut7q2q000gt4dd3w3kcsxx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dependencyInjection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/dependencyInjection/" class="article-date">
  <time datetime="2017-03-03T11:20:16.272Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>// 有多个类，主类car依赖Tires等类，常用的方法是，在主类头部引入依赖类，并在构造函数内，实例化一个该依赖类的实例，但是这样不好，当依赖类改变时，需要修改主类的代码，而且在这里实例化的实例也不能被其他类引用<br>export class Car {<br>  public engine: Engine;<br>  public tires: Tires;<br>  public description = ‘No DI’;<br>  constructor() {<br>    this.engine = new Engine();<br>    this.tires = new Tires();<br>  }<br>  // Method using the engine and tires<br>  drive() {<br>    return <code>${this.description} car with</code> +<br>      <code>${this.engine.cylinders} cylinders and ${this.tires.make} tires.</code><br>  }<br>}</p>
<p>// 一个方法是，我只在主类的构造函数内声明所以赖的类，并不实例化<br>// 如下，向主类传递实例，这样主类只顾用<br>constructor(public engine: Engine, public tires: Tires) { }</p>
<p>// 但是这样仍然需要手动为每个实例创建,于是，让每个类有一个对应的provider用来写创建它实例的方法，为了方便各个类的创建管理，又有了容器，主类只需要声明所需依赖，容器会自动调用依赖类的provider创建方法，并把实例保存在容器内，主类可以从容器中拿出依赖直接使用<br>// 注意，一定要有一个provider方法，不然从容器中取出依赖时，容器不知道怎样创建这个实例，当然在ng2中，一般类不需要写provider方法，因为大多是new service就可以得到了，默认支持</p>
<p>但需要声明所用provider是什么，(一般在组件声明provider)然后所有子组件都可以用,当然一般情况下（子组件使用的是同一个实例）<br>//在父组件中<br>providers:[HeroService],</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/dependencyInjection/" data-id="cizut7q2m000et4ddi8pofi6c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-deamonAndPOrotol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/03/deamonAndPOrotol/" class="article-date">
  <time datetime="2017-03-03T11:20:16.272Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="title-deamon与服务"><a href="#title-deamon与服务" class="headerlink" title="title:deamon与服务"></a>title:deamon与服务</h2><h3 id="每个系统服务对应一个deamon-deamon分为两种，一种是stand-alone-另一种是super-deamon-stand-alone-是启动后一直在内存中，而后者是一个系统超级deamon，它常存与内存，负责等待客户端请求来临，并根据来临的请求启动相应的软件程序服务和进程，打开一个新的deamon1，在完成工作后将deamon1删除。"><a href="#每个系统服务对应一个deamon-deamon分为两种，一种是stand-alone-另一种是super-deamon-stand-alone-是启动后一直在内存中，而后者是一个系统超级deamon，它常存与内存，负责等待客户端请求来临，并根据来临的请求启动相应的软件程序服务和进程，打开一个新的deamon1，在完成工作后将deamon1删除。" class="headerlink" title="每个系统服务对应一个deamon,deamon分为两种，一种是stand_alone,另一种是super_deamon,stand-alone,是启动后一直在内存中，而后者是一个系统超级deamon，它常存与内存，负责等待客户端请求来临，并根据来临的请求启动相应的软件程序服务和进程，打开一个新的deamon1，在完成工作后将deamon1删除。"></a><strong>每个系统服务对应一个deamon</strong>,deamon分为两种，一种是stand_alone,另一种是super_deamon,stand-alone,是启动后一直在内存中，而后者是一个系统超级deamon，它常存与内存，负责等待客户端请求来临，并根据来临的请求启动相应的软件程序服务和进程，打开一个新的deamon1，在完成工作后将deamon1删除。</h3><p><img src="http://vbird.dic.ksu.edu.tw/linux_basic/0560daemons_files/super_daemon.gif"></p>
<h3 id="super-daemon处理事情有两种方式"><a href="#super-daemon处理事情有两种方式" class="headerlink" title="super_daemon处理事情有两种方式"></a>super_daemon处理事情有两种方式</h3><ol>
<li>单线程single thread,仅仅开启一个deamon</li>
<li>multi thread ,开多个deamon,</li>
</ol>
<h3 id="服务service对应一个端口，"><a href="#服务service对应一个端口，" class="headerlink" title="服务service对应一个端口，"></a>服务service对应一个端口，</h3><hr>
<ol>
<li>出现端口的原因是因为，ip决定了客户端访问的地址，但是主机提供多种服务（deamon），通过port就可以把它导向指定的deamo</li>
<li>查看系统服务信息</li>
</ol>
<hr>
<h3 id="一个大程序可以开多个进程，一个进程对应有一个唯一的进程号PID，一个进程会有一个唯一端口号用来对外界服务，（但一个进程可以对应多个端口"><a href="#一个大程序可以开多个进程，一个进程对应有一个唯一的进程号PID，一个进程会有一个唯一端口号用来对外界服务，（但一个进程可以对应多个端口" class="headerlink" title="一个大程序可以开多个进程，一个进程对应有一个唯一的进程号PID，一个进程会有一个唯一端口号用来对外界服务，（但一个进程可以对应多个端口)"></a>一个大程序可以开多个进程，一个进程对应有一个唯一的进程号PID，一个进程会有一个唯一端口号用来对外界服务，（但一个进程可以对应多个端口)</h3><ol>
<li>进程实际上是一堆二进制文件，任何二进制文件的执行都会得到一个PID号，从登陆的 shell( 执行的是.bash二进制文件） ,开始，在它里面运行的都是子进程，<br>ps -l 可以查看父PPID子PID进程间的PID号关系，</li>
</ol>
<h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><ol>
<li>ip协议 对应网络层， TCP ,对应传输层， Http ,是应用层 ，而socket,是利用ip/tcp对其的底层函数做一个api封装，因此它本身不是一种协议，而是一个接口，通过socket,便可以使用 ip/tcp,</li>
<li>TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。</li>
<li>UDP 不保证连接的成功，只负责把数据发送出去，TCP需要三次握手，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/services</div></pre></td></tr></table></figure>
<p>### </p>
<h3 id="deamon启动脚本，在-etc-init-d-下"><a href="#deamon启动脚本，在-etc-init-d-下" class="headerlink" title="deamon启动脚本，在/etc/init.d/下"></a>deamon启动脚本，在/etc/init.d/下</h3><h3 id="socket-io-学习"><a href="#socket-io-学习" class="headerlink" title="socket.io 学习"></a>socket.io 学习</h3><ol>
<li>此类有很多知识都涉及到了</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/03/deamonAndPOrotol/" data-id="cizut7q2j000ct4ddhalev2j8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/03/yii/session/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/03/hexo/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/03/winTips/">一些小技巧</a>
          </li>
        
          <li>
            <a href="/2017/03/03/win7Clean/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/03/webpack/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>